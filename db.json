{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/ClassBytecode.png","path":"images/ClassBytecode.png","modified":1,"renderable":0},{"_id":"source/images/acid.png","path":"images/acid.png","modified":1,"renderable":0},{"_id":"source/images/assembly_1.png","path":"images/assembly_1.png","modified":1,"renderable":0},{"_id":"source/images/assembly_2.png","path":"images/assembly_2.png","modified":1,"renderable":0},{"_id":"source/images/satb.png","path":"images/satb.png","modified":1,"renderable":0},{"_id":"source/images/G1Gen.png","path":"images/G1Gen.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/hexo_icon.png","path":"images/hexo_icon.png","modified":1,"renderable":1},{"_id":"source/images/tidb-architecture.png","path":"images/tidb-architecture.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"554df7aa2bf576c72d103851c68b5b90bd99f8f0","modified":1551842232331},{"_id":"themes/next/.DS_Store","hash":"193c246ea147efacb1235975eab70b0b74fae93a","modified":1550382632495},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1545283632502},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1545283632501},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1545283632502},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1545283632503},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1545283632503},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1545283632503},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1545283632503},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1545283632503},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1545283632504},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1545283632504},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1545283632504},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1545283632504},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1545283632506},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1545283632506},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1545283632528},{"_id":"themes/next/_config.yml","hash":"017ac49198835042d2764cd8a7caf6980a4d4799","modified":1551232304615},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1551842239491},{"_id":"source/_posts/SingletonPattern.md","hash":"132c1193540fb978b2e7a47d82d4dc78b895651a","modified":1545287081141},{"_id":"source/_posts/Java内存模型与volatile实现原理.md","hash":"1b52328661094f68aee55b41ad1de92cc07cb304","modified":1545290317936},{"_id":"source/_posts/InnoDB如何保证事务四大特性.md","hash":"06442be15d86f686871fbf451930ab9296095d53","modified":1545290297677},{"_id":"source/_posts/剑指Offer题解.md","hash":"d4960862720b335b03e3106bfb5f1ab573f62dec","modified":1551873335856},{"_id":"source/_posts/InnoDB索引详解.md","hash":"e1d1232dfaf3c5c8271d01a3bfdc89d9f503d004","modified":1545288153076},{"_id":"source/_posts/深入理解CAS.md","hash":"325c3d32be1ee9d4bab2a08f41911d5d409b86ea","modified":1545289275634},{"_id":"source/_posts/方法区的OOM.md","hash":"4c157479f87bc09a4067c8be2d3176d4f92117aa","modified":1545288292699},{"_id":"source/_posts/对G1算法和G1垃圾回收器的理解.md","hash":"c2d65f4ab4edfe538287061b39e5cdc240a95f6b","modified":1547025795846},{"_id":"source/about/index.md","hash":"2659cc6ca9f33fe77e2ee6b9add4a99b5c14d9a1","modified":1550453645095},{"_id":"source/categories/index.md","hash":"c98be422cd2131c3e265936d07f2655a84c3dcff","modified":1545284725552},{"_id":"source/images/ClassBytecode.png","hash":"da2996602741d8c540a7f742edab37353799c6d4","modified":1545280922446},{"_id":"source/images/acid.png","hash":"3695b6a75f7558d8cfa652986a3369dd7a544b17","modified":1545281960965},{"_id":"source/images/assembly_1.png","hash":"3c04e004aff03a0ea992878df43f5c01c16be730","modified":1545280907316},{"_id":"source/images/assembly_2.png","hash":"2208b0baabf0e2ce2bbc258b16ce70e6a72a9269","modified":1545280896231},{"_id":"source/resume/index.md","hash":"c67a981f30780e03de74e0bc07d564d3158b27d0","modified":1553737923152},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1545283632493},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1545283632495},{"_id":"source/images/satb.png","hash":"c4078e8f8a8ac61d61db1ef80cf3cecc6b7af48c","modified":1546835858511},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1545283477908},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1545283632490},{"_id":"themes/next/.git/index","hash":"aeecbfea63bdfe03b2470ab9d13f9d94a5536af8","modified":1550383837891},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1545283632502},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1545283632503},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1545283632502},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1545283632503},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1545283632507},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1545283632506},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1545283632507},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1545283632507},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1545283632507},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1545283632508},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1545283632508},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1545283632508},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1545283632508},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1545283632508},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1545283632508},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1545283632509},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1545283632509},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1545283632528},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1545283632509},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1545283632509},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1545283632528},{"_id":"themes/next/languages/zh-Hans.yml","hash":"4bbe1468774245defbc809b6c4556f6f0b922185","modified":1550383661628},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1545283632510},{"_id":"themes/next/layout/.DS_Store","hash":"ec8152c6e9c4441f4e7a65ea385201c62640b820","modified":1550382627482},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1545283632526},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1545283632526},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1545283632527},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1545283632527},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1545283632527},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1545283632527},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1545283632527},{"_id":"themes/next/source/.DS_Store","hash":"5e2b4ea6101f482e770c3cece21c929dd0145e25","modified":1550382663090},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1545283632607},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1545283632606},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1545283632607},{"_id":"source/images/G1Gen.png","hash":"81b1056f6f801f2a19265fab596cb08caf591a2f","modified":1546853048614},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632558},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1545283477908},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1545283477909},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1545283477909},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1545283477910},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1545283477909},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1545283477910},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1545283477909},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1545283477910},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1545283477909},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1545283477910},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1545283477909},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1545283477910},{"_id":"themes/next/.git/logs/HEAD","hash":"d057b77e146dda1c3d19576436ed60b480dcc93d","modified":1545283632494},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1545283632529},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1545283632529},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1545283632529},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1545283632529},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1545283632530},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1545283632530},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1545283632530},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1545283632530},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1545283632531},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1545283632510},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1545283632510},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545283632510},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1545283632510},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1545283632511},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1545283632511},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1545283632516},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1545283632511},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1545283632511},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1545283632516},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1545283632517},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1545283632522},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1545283632522},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1545283632523},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1545283632523},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1545283632522},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1545283632522},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1545283632523},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1545283632512},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1545283632513},{"_id":"themes/next/layout/_partials/footer.swig","hash":"b9f8fa37ac92eb3e673d70df4dc11f3c6d29467f","modified":1545286598886},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1545283632513},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1545283632513},{"_id":"themes/next/layout/_partials/head.swig","hash":"aba001e18638d568e5a1bf27429b16e6f901dd2a","modified":1550823925806},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1545283632514},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1545283632557},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1545283632558},{"_id":"themes/next/source/js/.DS_Store","hash":"f3dfc86287a461aa6605c52f49f2a4129a910b4e","modified":1550382663093},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545283632559},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545283632559},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1545283632559},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1545283632559},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1545283632560},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1545283632560},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1545283632560},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1545283632561},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545283632561},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1545283632560},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545283632561},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545283632561},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1545283632561},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545283632561},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1545283632562},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1545283632562},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545283632562},{"_id":"themes/next/source/images/hexo_icon.png","hash":"845b4c44e455f3ef6878f39e5808c8bfef9b742b","modified":1543453133691},{"_id":"source/images/tidb-architecture.png","hash":"91184454979b4c034dc2837dbb6399fd12b60e62","modified":1551857476586},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632517},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632516},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632556},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632557},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632550},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632550},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545283632550},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1545283632494},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1545283632516},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545283632516},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1545283632517},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1545283632517},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1545283632517},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1545283632517},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1545283632518},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1545283632519},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1545283632519},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1545283632519},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1545283632519},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1545283632520},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1545283632520},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1545283632520},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1545283632521},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1545283632521},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1545283632521},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1545283632521},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1545283632521},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1545283632521},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1545283632525},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1545283632525},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1545283632525},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1545283632526},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1545283632513},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1545283632513},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1545283632514},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1545283632515},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1545283632514},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1545283632515},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1545283632515},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1545283632515},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1545283632516},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1545283632556},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1545283632556},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1545283632557},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1545283632557},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1545283632550},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1545283632550},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1545283632550},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1545283632550},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1545283632562},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1545283632563},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1545283632563},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1545283632563},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1545283632563},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545283632563},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1545283632563},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1545283632564},{"_id":"themes/next/source/js/src/.DS_Store","hash":"9454aa10ea341120af9a19527c3d92bc99114356","modified":1550384582699},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1545283632564},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1545283632564},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1545283632564},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1545283632571},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1545283632568},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1545283632571},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1545283632572},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1545283632572},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1545283632577},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1545283632577},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1545283632577},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1545283632577},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1545283632578},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1545283632578},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1545283632579},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1545283632578},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1545283632579},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1545283632591},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1545283632592},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1545283632593},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1545283632594},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1545283632593},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1545283632593},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1545283632593},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1545283632594},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1545283632595},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1545283632595},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1545283632595},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1545283632594},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1545283632595},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1545283632595},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1545283632596},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1545283632596},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1545283632596},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1545283632596},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1545283632597},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1545283632597},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1545283632597},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1545283632596},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1545283632597},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1545283632597},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1545283632598},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1545283632598},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1545283632598},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1545283632602},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1545283632602},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545283632606},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545283632605},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545283632606},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545283632592},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1545283632493},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"d057b77e146dda1c3d19576436ed60b480dcc93d","modified":1545283632494},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1545283632524},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1545283632524},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1545283632532},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1545283632532},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1545283632532},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1545283632532},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1545283632532},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1545283632536},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1545283632548},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1545283632543},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1545283632549},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1545283632548},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1545283632549},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1545283632548},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1545283632549},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1545283632549},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1545283632551},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1545283632551},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1545283632551},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1545283632551},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545283632552},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1545283632552},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1545283632552},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1545283632552},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1545283632553},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1545283632554},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1545283632554},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1545283632554},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1545283632553},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1545283632555},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1545283632555},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1545283632555},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1545283632555},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1545283632556},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1545283632555},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1545283632564},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1545283632573},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1545283632572},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1545283632567},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1545283632574},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1545283632573},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1545283632568},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1545283632574},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1545283632574},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1545283632576},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1545283632576},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1545283632578},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1545283632578},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1545283632576},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1545283632579},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1545283632579},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1545283632580},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1545283632602},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1545283632602},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1545283632566},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1545283632567},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545283632591},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545283632590},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545283632604},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"d057b77e146dda1c3d19576436ed60b480dcc93d","modified":1545283632492},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1545283632534},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1545283632534},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1545283632534},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1545283632533},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1545283632535},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1545283632535},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1545283632535},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1545283632536},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1545283632535},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1545283632540},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1545283632540},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1545283632541},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1545283632542},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1545283632541},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1545283632542},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1545283632542},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1545283632543},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1545283632543},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1545283632543},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1545283632536},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1545283632536},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1545283632537},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1545283632537},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1545283632537},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1545283632537},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1545283632538},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1545283632538},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1545283632538},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1545283632538},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1545283632538},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1545283632539},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1545283632539},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1545283632539},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1545283632539},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1545283632544},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1545283632544},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1545283632543},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1545283632544},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1545283632545},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1545283632544},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1545283632544},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1545283632545},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1545283632545},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1545283632545},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1545283632545},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1545283632546},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1545283632547},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1545283632547},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545283632553},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1545283632553},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1545283632554},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1545283632565},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1545283632565},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1545283632566},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1545283632566},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1545283632566},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1545283632575},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1545283632575},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1545283632575},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1545283632575},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1545283632575},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1545283632575},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545283632582},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545283632584},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545283632589},{"_id":"themes/next/.git/objects/pack/pack-ce5aaead4992c77ad89f7e79922d1bf5a1722825.idx","hash":"46daad4f50a8d605fab4a73d47b5e337584c74e1","modified":1545283632476},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1545283632571},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1545283632601},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545283632587},{"_id":"themes/next/.git/objects/pack/pack-ce5aaead4992c77ad89f7e79922d1bf5a1722825.pack","hash":"ed31d195350fff8a6c36475009cdebf86890e420","modified":1545283632470},{"_id":"public/about/index.html","hash":"b304244e13eba986f3ba78b367c7adaff9ffa93c","modified":1553737944346},{"_id":"public/categories/index.html","hash":"2ec11d543b3d283cade60802548059115ae3ca5c","modified":1553737944346},{"_id":"public/archives/2018/index.html","hash":"b9721a12219e3aa13c4d4c03c98f2675c1f63bb0","modified":1553737944346},{"_id":"public/archives/2018/12/index.html","hash":"d6217d606ba12bd73cbfe20b4da1d1beb3a64d4d","modified":1553737944346},{"_id":"public/archives/2019/index.html","hash":"92a0e1f04649581cfa4ab20380fdaac961694171","modified":1553737944346},{"_id":"public/archives/2019/01/index.html","hash":"3f7fab097201c775826d2dfa09d53c65fd430261","modified":1553737944346},{"_id":"public/archives/2019/02/index.html","hash":"ea29ef39438a71fa722cec8a1c10165d4793fae0","modified":1553737944346},{"_id":"public/categories/Java多线程/index.html","hash":"02499552ab41879bf0439400a1e6e9adf8c18625","modified":1553737944346},{"_id":"public/categories/数据库/index.html","hash":"8fa4d042f83cba969790fcfd841d54f6db5b57fd","modified":1553737944346},{"_id":"public/categories/JVM/index.html","hash":"e808fbefde6cdaa92736449c0bf50d34e1980cac","modified":1553737944346},{"_id":"public/categories/Algorithms/index.html","hash":"f094db2e58fed6533b28ad3aaf8189c55730084b","modified":1553737944346},{"_id":"public/resume/index.html","hash":"4d09a52e0be2c76f05806203aea67375a9992780","modified":1553737944346},{"_id":"public/2019/02/18/剑指Offer题解/index.html","hash":"942e5862243e606729d6b1b50a8bd57223293965","modified":1553737944346},{"_id":"public/2019/01/06/对G1算法和G1垃圾回收器的理解/index.html","hash":"fe1987192ebbb36d4534619c4f06c5bc3a5d42f0","modified":1553737944346},{"_id":"public/2018/12/20/方法区的OOM/index.html","hash":"73d7874fedcddbb1c3282a8a425904a63379f9e8","modified":1553737944346},{"_id":"public/2018/12/20/InnoDB如何保证事务四大特性/index.html","hash":"e5b70b02146986b4a0a24d92e8024716259e7a52","modified":1553737944346},{"_id":"public/2018/12/20/InnoDB索引详解/index.html","hash":"36ac9f3986acda346290324214a3423605367401","modified":1553737944346},{"_id":"public/2018/12/20/深入理解CAS/index.html","hash":"c03845bd82165fffbef36d8a00e1003a5564d312","modified":1553737944346},{"_id":"public/2018/12/20/Java内存模型与volatile实现原理/index.html","hash":"ebdb2632b002b72290fe1c19833b8f60783fe9c3","modified":1553737944347},{"_id":"public/2018/12/20/SingletonPattern/index.html","hash":"3fa005c9f6f5758cec818a9cd9b0a5e02bb375a8","modified":1553737944347},{"_id":"public/archives/index.html","hash":"652d9091370a56c48f762f821d35e83a6b6635df","modified":1553737944347},{"_id":"public/index.html","hash":"95b90d4d219c0c11a841c3db84df8849cef1b850","modified":1553737944347},{"_id":"public/images/ClassBytecode.png","hash":"da2996602741d8c540a7f742edab37353799c6d4","modified":1553737944351},{"_id":"public/images/acid.png","hash":"3695b6a75f7558d8cfa652986a3369dd7a544b17","modified":1553737944351},{"_id":"public/images/assembly_1.png","hash":"3c04e004aff03a0ea992878df43f5c01c16be730","modified":1553737944351},{"_id":"public/images/assembly_2.png","hash":"2208b0baabf0e2ce2bbc258b16ce70e6a72a9269","modified":1553737944351},{"_id":"public/images/satb.png","hash":"c4078e8f8a8ac61d61db1ef80cf3cecc6b7af48c","modified":1553737944351},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553737944351},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1553737944351},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1553737944351},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1553737944351},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1553737944352},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1553737944352},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1553737944352},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1553737944352},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1553737944352},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1553737944352},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1553737944352},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1553737944352},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553737944352},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1553737944352},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553737944352},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1553737944352},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1553737944352},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1553737944352},{"_id":"public/images/hexo_icon.png","hash":"845b4c44e455f3ef6878f39e5808c8bfef9b742b","modified":1553737944352},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553737944352},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553737944352},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553737944352},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553737944352},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553737944352},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553737944352},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553737944352},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553737944352},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553737944352},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553737944352},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553737944352},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553737944352},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553737944353},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553737944353},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1553737944353},{"_id":"public/images/G1Gen.png","hash":"81b1056f6f801f2a19265fab596cb08caf591a2f","modified":1553737944730},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553737944733},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553737944734},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1553737944737},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1553737944738},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553737944738},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1553737944738},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553737944738},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553737944738},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1553737944738},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553737944738},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1553737944738},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1553737944738},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553737944738},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553737944738},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1553737944738},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1553737944738},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553737944738},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1553737944738},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553737944738},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553737944738},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553737944738},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553737944739},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553737944739},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1553737944739},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1553737944739},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553737944739},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553737944739},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553737944739},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553737944739},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553737944739},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553737944739},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553737944739},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1553737944739},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1553737944739},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1553737944739},{"_id":"public/css/main.css","hash":"77ee0f34aaf5ed59ac212e5287a36ce16e991e23","modified":1553737944739},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553737944739},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553737944739},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553737944739},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1553737944743},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1553737944743},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553737944744},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553737944744},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553737944744},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553737944744},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553737944744},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553737944744},{"_id":"public/images/tidb-architecture.png","hash":"91184454979b4c034dc2837dbb6399fd12b60e62","modified":1553737944744},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1553737944746},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553737944746},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553737944749},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553737944750},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1553737944756},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553737944756},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1553737944757},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553737944757},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553737944757},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553737944757},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553737944757},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1553737944761},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553737944761},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553737944761},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553737944766},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553737944772},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553737944774},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553737944776},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553737944779},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553737944787},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553737944789}],"Category":[{"name":"Java多线程","_id":"cjtrzgdmt0004dcxvj84k1raw"},{"name":"数据库","_id":"cjtrzgdmz000adcxvya62cnum"},{"name":"JVM","_id":"cjtrzgdn0000fdcxvs8rsezdw"},{"name":"Algorithms","_id":"cjtrzgdqh000mdcxvgcrlykoq"}],"Data":[],"Page":[{"title":"About Me","date":"2018-12-20T05:47:43.000Z","_content":"\n由于之前博客源文件丢失，我在2018.12.20号重新发布了2018年及之前的博客，所以，之前的博客时间都是2018.12.20\n\nPurpose\n---\n目前博客仅用于输出学习心得和钻研问题的成果\n\nMajor\n---\n计算机科学与技术\n\nWork\n---\n目前效力于网易有道，Java开发实习生。\n\nGitHub\n---\n[Julindada](https://github.com/Julindada)\n\nPersonal Tag\n---\n喜欢思考，历史，文学《论语》，电影（尤其悬疑电影）\n","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2018-12-20 13:47:43\n---\n\n由于之前博客源文件丢失，我在2018.12.20号重新发布了2018年及之前的博客，所以，之前的博客时间都是2018.12.20\n\nPurpose\n---\n目前博客仅用于输出学习心得和钻研问题的成果\n\nMajor\n---\n计算机科学与技术\n\nWork\n---\n目前效力于网易有道，Java开发实习生。\n\nGitHub\n---\n[Julindada](https://github.com/Julindada)\n\nPersonal Tag\n---\n喜欢思考，历史，文学《论语》，电影（尤其悬疑电影）\n","updated":"2019-02-18T01:34:05.095Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtrzgdmq0001dcxvbjil329h","content":"<p>由于之前博客源文件丢失，我在2018.12.20号重新发布了2018年及之前的博客，所以，之前的博客时间都是2018.12.20</p>\n<h2 id=\"Purpose\"><a href=\"#Purpose\" class=\"headerlink\" title=\"Purpose\"></a>Purpose</h2><p>目前博客仅用于输出学习心得和钻研问题的成果</p>\n<h2 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h2><p>计算机科学与技术</p>\n<h2 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h2><p>目前效力于网易有道，Java开发实习生。</p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><p><a href=\"https://github.com/Julindada\" target=\"_blank\" rel=\"noopener\">Julindada</a></p>\n<h2 id=\"Personal-Tag\"><a href=\"#Personal-Tag\" class=\"headerlink\" title=\"Personal Tag\"></a>Personal Tag</h2><p>喜欢思考，历史，文学《论语》，电影（尤其悬疑电影）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于之前博客源文件丢失，我在2018.12.20号重新发布了2018年及之前的博客，所以，之前的博客时间都是2018.12.20</p>\n<h2 id=\"Purpose\"><a href=\"#Purpose\" class=\"headerlink\" title=\"Purpose\"></a>Purpose</h2><p>目前博客仅用于输出学习心得和钻研问题的成果</p>\n<h2 id=\"Major\"><a href=\"#Major\" class=\"headerlink\" title=\"Major\"></a>Major</h2><p>计算机科学与技术</p>\n<h2 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h2><p>目前效力于网易有道，Java开发实习生。</p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><p><a href=\"https://github.com/Julindada\" target=\"_blank\" rel=\"noopener\">Julindada</a></p>\n<h2 id=\"Personal-Tag\"><a href=\"#Personal-Tag\" class=\"headerlink\" title=\"Personal Tag\"></a>Personal Tag</h2><p>喜欢思考，历史，文学《论语》，电影（尤其悬疑电影）</p>\n"},{"title":"categories","date":"2018-12-20T05:41:12.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-12-20 13:41:12\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-12-20T05:45:25.552Z","path":"categories/index.html","layout":"page","_id":"cjtrzgdms0003dcxv99trtnjl","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"default","password":"julin233","_content":"\n <div align=\"center\">\n     <h1>朱琳</h1>\n     <div>\n     电话：17602299297&nbsp;·&nbsp;邮箱：frankzhu233@gmail.com&nbsp;·&nbsp;博客：<a href=\"https://julindada.github.io/\">julindada.github.io</a>\n     </div>\n </div>\n\n\n\n\n\n## 个人信息\n\n\n - 性别：男\n\n - 出生日期：1997.07\n\n - 求职意向：后端开发工程师\n\n\n## 教育经历\n\n- 学士，天津科技大学，计算机科学与信息工程学院，计算机科学与技术专业，2015.9~2019.7\n\n\n## 个人能力及特长\n\n\n- 大学主修基础课程：数据结构、算法、计算机网络、操作系统。(熟悉TCP头的数据，以及各个字段的意义，包括seq计算方式、RST攻击原理、SYN flood，拜读过《TCP/IP详解》的TCP章节，但因本人技术有限还未完全理解)\n\n- 开发语言基础：熟练掌握**Java、JVM、Java多线程**、设计模式，阅读过部分JDK源码，了解Python(Flask框架)、Shell脚本\n\n- 分布式：了解Paxos、Raft一致性算法，HDFS的使用，分布式思想和解决问题的方法\n\n- Web开发：掌握Spring/SpringMVC/ Mybatis/Spring boot开发使用。了解tomcat、nginx、RPC框架的使用\n\n- 前端（包括移动端）：掌握Bootstrap、jQuery、Vue等前端框架，了解kotlin以及Anko库开发Android\n\n- 数据库相关：**掌握MySQL的InnoDB存储引擎**、了解Redis底层原理、分布式数据库TiDB及其技术内幕\n\n- 版本管理和自动构建工具：有Svn/Git基础，会使用maven、gradle\n\n- 操作系统：**Ubuntu/Debian/CentOS**。熟悉常用Linux命令和Linux思想\n\n- Geek精神：非常喜欢学习新技能/钻研技术/探究技术的原理/有Web安全基础/喜欢玩Linux(比如vim、tmux等终端神器)/虽然暂时技能树广度不足，但学习加速度很大 \n\n\n## 工作经历\n\n- **网易，精品课研发组，Java开发工程师，2019.02~至今**\n\n  ​\t负责精品课相关业务的研发，MySQL迁移到TiDB。\n\n- **京东数科/京东金融，信贷与对公研发组，Java开发工程师，2018.09~2019.01**\n\n  ​\t负责部门核心项目-企业融资项目开发，熟悉了主要的信用贷流程，包括授信/提款/还款流程开发。\n\n  ​\t还了解了分布式相关知识，包括分布式调度、分布式存储、技术选型等，并且现在还在持续学习分布式。\n\n\n## 项目经历\n\n- **企业融资系统\t/\tJava后端开发\t/\t2018.10~2019.01**\n\n\t​\t该系统是我在京东参与的一个企业融资项目，从立项到第三期需求上线，我全程参与，该系统是对B端信贷中台的第一个模型(包括数据模型)。将来在这个系统的基础上会建立一个业务中台。\n\t\n\t​\t该项目使用了Spring、Spring MVC、Mybatis等框架，MySQL使用的是InnoDB存储引擎，其中通RPC框架解除系统耦合、分发系统压力(个人理解)。\n\t\n\t​\t在该项目中我学到的技能：RPC框架的使用(即消费者/生产者)、Redis数据结构和使用、InnoDB存储引擎使用的一次实战、分布式系统思维（例如，系统低耦合、高可用等）。\n\t\n\t​\t开发过程中的思考：数据库索引、唯一索引的设计方式。RPC调用通过JSON传参降低项目模块之间耦合性，提高可扩展性。通过负载均衡、定时任务设计、代码的时间空间复杂度分析等提高效率。包括提款、还款业务的原子性设计问题。\n\t\n- **学校选课查询系统\t/\tJava后端开发\t/\t2017.11~2019.12**\n\t\n\t​\t该项目由天津科技大学教务处委托设计用于学生查询选课信息。\n\t\n\t​\t项目功能包括:教务处可在 web 端上传 Excel 文件导入数据库。可在另一个web端通过学号、班级号、校区等查询需要选修的课程、课程号等。\n\n\t​\t该项目使用了Spring boot、Spring、Spring MVC、Mybatis等框架集成了后端，使用MySQL数据库，使用索引提高查询速度（只在教务处上传文件时有数据的修改、所以建立索引的熟数量并不会影响学生查询效率），使用Nginx作为反向代理（在本机的开发过程中搭建了伪分布式环境）。\n\n- **基于物联网的化工园区危险源监测系统\t/\tAndroid开发\t\t/\t2016.10~2016.11** \n\n  ​\t2015年，8.12塘沽大爆炸事件反映出了化工园区危险源监管不严问题，该系统应运而生。\n\n  ​\t该项目移动端使用原生Android开发，使用了MQTT协议和github上知名的图表控件MPAndroidChart。\n\n  ​\t该项目在2016年以大学生创新创业大赛国家级项目立项，申请了软著和专利，并在多个比赛中获奖。\n\n\n## 个人总结\n\n从不认为哪种技术很重要，重要的是思想，或者是解决问题的方法，这些方法的修改/组合可能以后会解决一个或多个问题。一个很简单的例子，TCP的可靠性使其繁重，那么基于UDP的这种可靠性为什么不能在应用层，根据业务定制呢？这里除了应用到TCP实现可靠性的方法，还有一种分层的思想，这种思想的应用我大概也能说一堆。那么如何做到修改/组合这些思想？需要的是软实力/学习力，正好我具备，且在不断学习，而你也需要这样的人。\n","source":"resume/index.md","raw":"---\nlayout: default\npassword: julin233\n---\n\n <div align=\"center\">\n     <h1>朱琳</h1>\n     <div>\n     电话：17602299297&nbsp;·&nbsp;邮箱：frankzhu233@gmail.com&nbsp;·&nbsp;博客：<a href=\"https://julindada.github.io/\">julindada.github.io</a>\n     </div>\n </div>\n\n\n\n\n\n## 个人信息\n\n\n - 性别：男\n\n - 出生日期：1997.07\n\n - 求职意向：后端开发工程师\n\n\n## 教育经历\n\n- 学士，天津科技大学，计算机科学与信息工程学院，计算机科学与技术专业，2015.9~2019.7\n\n\n## 个人能力及特长\n\n\n- 大学主修基础课程：数据结构、算法、计算机网络、操作系统。(熟悉TCP头的数据，以及各个字段的意义，包括seq计算方式、RST攻击原理、SYN flood，拜读过《TCP/IP详解》的TCP章节，但因本人技术有限还未完全理解)\n\n- 开发语言基础：熟练掌握**Java、JVM、Java多线程**、设计模式，阅读过部分JDK源码，了解Python(Flask框架)、Shell脚本\n\n- 分布式：了解Paxos、Raft一致性算法，HDFS的使用，分布式思想和解决问题的方法\n\n- Web开发：掌握Spring/SpringMVC/ Mybatis/Spring boot开发使用。了解tomcat、nginx、RPC框架的使用\n\n- 前端（包括移动端）：掌握Bootstrap、jQuery、Vue等前端框架，了解kotlin以及Anko库开发Android\n\n- 数据库相关：**掌握MySQL的InnoDB存储引擎**、了解Redis底层原理、分布式数据库TiDB及其技术内幕\n\n- 版本管理和自动构建工具：有Svn/Git基础，会使用maven、gradle\n\n- 操作系统：**Ubuntu/Debian/CentOS**。熟悉常用Linux命令和Linux思想\n\n- Geek精神：非常喜欢学习新技能/钻研技术/探究技术的原理/有Web安全基础/喜欢玩Linux(比如vim、tmux等终端神器)/虽然暂时技能树广度不足，但学习加速度很大 \n\n\n## 工作经历\n\n- **网易，精品课研发组，Java开发工程师，2019.02~至今**\n\n  ​\t负责精品课相关业务的研发，MySQL迁移到TiDB。\n\n- **京东数科/京东金融，信贷与对公研发组，Java开发工程师，2018.09~2019.01**\n\n  ​\t负责部门核心项目-企业融资项目开发，熟悉了主要的信用贷流程，包括授信/提款/还款流程开发。\n\n  ​\t还了解了分布式相关知识，包括分布式调度、分布式存储、技术选型等，并且现在还在持续学习分布式。\n\n\n## 项目经历\n\n- **企业融资系统\t/\tJava后端开发\t/\t2018.10~2019.01**\n\n\t​\t该系统是我在京东参与的一个企业融资项目，从立项到第三期需求上线，我全程参与，该系统是对B端信贷中台的第一个模型(包括数据模型)。将来在这个系统的基础上会建立一个业务中台。\n\t\n\t​\t该项目使用了Spring、Spring MVC、Mybatis等框架，MySQL使用的是InnoDB存储引擎，其中通RPC框架解除系统耦合、分发系统压力(个人理解)。\n\t\n\t​\t在该项目中我学到的技能：RPC框架的使用(即消费者/生产者)、Redis数据结构和使用、InnoDB存储引擎使用的一次实战、分布式系统思维（例如，系统低耦合、高可用等）。\n\t\n\t​\t开发过程中的思考：数据库索引、唯一索引的设计方式。RPC调用通过JSON传参降低项目模块之间耦合性，提高可扩展性。通过负载均衡、定时任务设计、代码的时间空间复杂度分析等提高效率。包括提款、还款业务的原子性设计问题。\n\t\n- **学校选课查询系统\t/\tJava后端开发\t/\t2017.11~2019.12**\n\t\n\t​\t该项目由天津科技大学教务处委托设计用于学生查询选课信息。\n\t\n\t​\t项目功能包括:教务处可在 web 端上传 Excel 文件导入数据库。可在另一个web端通过学号、班级号、校区等查询需要选修的课程、课程号等。\n\n\t​\t该项目使用了Spring boot、Spring、Spring MVC、Mybatis等框架集成了后端，使用MySQL数据库，使用索引提高查询速度（只在教务处上传文件时有数据的修改、所以建立索引的熟数量并不会影响学生查询效率），使用Nginx作为反向代理（在本机的开发过程中搭建了伪分布式环境）。\n\n- **基于物联网的化工园区危险源监测系统\t/\tAndroid开发\t\t/\t2016.10~2016.11** \n\n  ​\t2015年，8.12塘沽大爆炸事件反映出了化工园区危险源监管不严问题，该系统应运而生。\n\n  ​\t该项目移动端使用原生Android开发，使用了MQTT协议和github上知名的图表控件MPAndroidChart。\n\n  ​\t该项目在2016年以大学生创新创业大赛国家级项目立项，申请了软著和专利，并在多个比赛中获奖。\n\n\n## 个人总结\n\n从不认为哪种技术很重要，重要的是思想，或者是解决问题的方法，这些方法的修改/组合可能以后会解决一个或多个问题。一个很简单的例子，TCP的可靠性使其繁重，那么基于UDP的这种可靠性为什么不能在应用层，根据业务定制呢？这里除了应用到TCP实现可靠性的方法，还有一种分层的思想，这种思想的应用我大概也能说一堆。那么如何做到修改/组合这些思想？需要的是软实力/学习力，正好我具备，且在不断学习，而你也需要这样的人。\n","date":"2019-03-28T01:52:03.156Z","updated":"2019-03-28T01:52:03.152Z","path":"resume/index.html","title":"","comments":1,"_id":"cjtrzgdqe000kdcxvi1mokwc3","content":" <div align=\"center\"><br>     <h1>朱琳</h1><br>     <div><br>     电话：17602299297&nbsp;·&nbsp;邮箱：<a href=\"mailto:frankzhu233@gmail.com\" target=\"_blank\" rel=\"noopener\">frankzhu233@gmail.com</a>&nbsp;·&nbsp;博客：<a href=\"https://julindada.github.io/\" target=\"_blank\" rel=\"noopener\">julindada.github.io</a><br>     </div><br> </div>\n\n\n\n\n\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li><p>性别：男</p>\n</li>\n<li><p>出生日期：1997.07</p>\n</li>\n<li><p>求职意向：后端开发工程师</p>\n</li>\n</ul>\n<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><ul>\n<li>学士，天津科技大学，计算机科学与信息工程学院，计算机科学与技术专业，2015.9~2019.7</li>\n</ul>\n<h2 id=\"个人能力及特长\"><a href=\"#个人能力及特长\" class=\"headerlink\" title=\"个人能力及特长\"></a>个人能力及特长</h2><ul>\n<li><p>大学主修基础课程：数据结构、算法、计算机网络、操作系统。(熟悉TCP头的数据，以及各个字段的意义，包括seq计算方式、RST攻击原理、SYN flood，拜读过《TCP/IP详解》的TCP章节，但因本人技术有限还未完全理解)</p>\n</li>\n<li><p>开发语言基础：熟练掌握<strong>Java、JVM、Java多线程</strong>、设计模式，阅读过部分JDK源码，了解Python(Flask框架)、Shell脚本</p>\n</li>\n<li><p>分布式：了解Paxos、Raft一致性算法，HDFS的使用，分布式思想和解决问题的方法</p>\n</li>\n<li><p>Web开发：掌握Spring/SpringMVC/ Mybatis/Spring boot开发使用。了解tomcat、nginx、RPC框架的使用</p>\n</li>\n<li><p>前端（包括移动端）：掌握Bootstrap、jQuery、Vue等前端框架，了解kotlin以及Anko库开发Android</p>\n</li>\n<li><p>数据库相关：<strong>掌握MySQL的InnoDB存储引擎</strong>、了解Redis底层原理、分布式数据库TiDB及其技术内幕</p>\n</li>\n<li><p>版本管理和自动构建工具：有Svn/Git基础，会使用maven、gradle</p>\n</li>\n<li><p>操作系统：<strong>Ubuntu/Debian/CentOS</strong>。熟悉常用Linux命令和Linux思想</p>\n</li>\n<li><p>Geek精神：非常喜欢学习新技能/钻研技术/探究技术的原理/有Web安全基础/喜欢玩Linux(比如vim、tmux等终端神器)/虽然暂时技能树广度不足，但学习加速度很大 </p>\n</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><strong>网易，精品课研发组，Java开发工程师，2019.02~至今</strong></p>\n<p>​    负责精品课相关业务的研发，MySQL迁移到TiDB。</p>\n</li>\n<li><p><strong>京东数科/京东金融，信贷与对公研发组，Java开发工程师，2018.09~2019.01</strong></p>\n<p>​    负责部门核心项目-企业融资项目开发，熟悉了主要的信用贷流程，包括授信/提款/还款流程开发。</p>\n<p>​    还了解了分布式相关知识，包括分布式调度、分布式存储、技术选型等，并且现在还在持续学习分布式。</p>\n</li>\n</ul>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><ul>\n<li><p><strong>企业融资系统    /    Java后端开发    /    2018.10~2019.01</strong></p>\n<p>  ​    该系统是我在京东参与的一个企业融资项目，从立项到第三期需求上线，我全程参与，该系统是对B端信贷中台的第一个模型(包括数据模型)。将来在这个系统的基础上会建立一个业务中台。</p>\n<p>  ​    该项目使用了Spring、Spring MVC、Mybatis等框架，MySQL使用的是InnoDB存储引擎，其中通RPC框架解除系统耦合、分发系统压力(个人理解)。</p>\n<p>  ​    在该项目中我学到的技能：RPC框架的使用(即消费者/生产者)、Redis数据结构和使用、InnoDB存储引擎使用的一次实战、分布式系统思维（例如，系统低耦合、高可用等）。</p>\n<p>  ​    开发过程中的思考：数据库索引、唯一索引的设计方式。RPC调用通过JSON传参降低项目模块之间耦合性，提高可扩展性。通过负载均衡、定时任务设计、代码的时间空间复杂度分析等提高效率。包括提款、还款业务的原子性设计问题。</p>\n</li>\n<li><p><strong>学校选课查询系统    /    Java后端开发    /    2017.11~2019.12</strong></p>\n<p>  ​    该项目由天津科技大学教务处委托设计用于学生查询选课信息。</p>\n<p>  ​    项目功能包括:教务处可在 web 端上传 Excel 文件导入数据库。可在另一个web端通过学号、班级号、校区等查询需要选修的课程、课程号等。</p>\n<p>  ​    该项目使用了Spring boot、Spring、Spring MVC、Mybatis等框架集成了后端，使用MySQL数据库，使用索引提高查询速度（只在教务处上传文件时有数据的修改、所以建立索引的熟数量并不会影响学生查询效率），使用Nginx作为反向代理（在本机的开发过程中搭建了伪分布式环境）。</p>\n</li>\n<li><p><strong>基于物联网的化工园区危险源监测系统    /    Android开发        /    2016.10~2016.11</strong> </p>\n<p>​    2015年，8.12塘沽大爆炸事件反映出了化工园区危险源监管不严问题，该系统应运而生。</p>\n<p>​    该项目移动端使用原生Android开发，使用了MQTT协议和github上知名的图表控件MPAndroidChart。</p>\n<p>​    该项目在2016年以大学生创新创业大赛国家级项目立项，申请了软著和专利，并在多个比赛中获奖。</p>\n</li>\n</ul>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><p>从不认为哪种技术很重要，重要的是思想，或者是解决问题的方法，这些方法的修改/组合可能以后会解决一个或多个问题。一个很简单的例子，TCP的可靠性使其繁重，那么基于UDP的这种可靠性为什么不能在应用层，根据业务定制呢？这里除了应用到TCP实现可靠性的方法，还有一种分层的思想，这种思想的应用我大概也能说一堆。那么如何做到修改/组合这些思想？需要的是软实力/学习力，正好我具备，且在不断学习，而你也需要这样的人。</p>\n","site":{"data":{}},"excerpt":"","more":" <div align=\"center\"><br>     <h1>朱琳</h1><br>     <div><br>     电话：17602299297&nbsp;·&nbsp;邮箱：<a href=\"mailto:frankzhu233@gmail.com\" target=\"_blank\" rel=\"noopener\">frankzhu233@gmail.com</a>&nbsp;·&nbsp;博客：<a href=\"https://julindada.github.io/\" target=\"_blank\" rel=\"noopener\">julindada.github.io</a><br>     </div><br> </div>\n\n\n\n\n\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li><p>性别：男</p>\n</li>\n<li><p>出生日期：1997.07</p>\n</li>\n<li><p>求职意向：后端开发工程师</p>\n</li>\n</ul>\n<h2 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h2><ul>\n<li>学士，天津科技大学，计算机科学与信息工程学院，计算机科学与技术专业，2015.9~2019.7</li>\n</ul>\n<h2 id=\"个人能力及特长\"><a href=\"#个人能力及特长\" class=\"headerlink\" title=\"个人能力及特长\"></a>个人能力及特长</h2><ul>\n<li><p>大学主修基础课程：数据结构、算法、计算机网络、操作系统。(熟悉TCP头的数据，以及各个字段的意义，包括seq计算方式、RST攻击原理、SYN flood，拜读过《TCP/IP详解》的TCP章节，但因本人技术有限还未完全理解)</p>\n</li>\n<li><p>开发语言基础：熟练掌握<strong>Java、JVM、Java多线程</strong>、设计模式，阅读过部分JDK源码，了解Python(Flask框架)、Shell脚本</p>\n</li>\n<li><p>分布式：了解Paxos、Raft一致性算法，HDFS的使用，分布式思想和解决问题的方法</p>\n</li>\n<li><p>Web开发：掌握Spring/SpringMVC/ Mybatis/Spring boot开发使用。了解tomcat、nginx、RPC框架的使用</p>\n</li>\n<li><p>前端（包括移动端）：掌握Bootstrap、jQuery、Vue等前端框架，了解kotlin以及Anko库开发Android</p>\n</li>\n<li><p>数据库相关：<strong>掌握MySQL的InnoDB存储引擎</strong>、了解Redis底层原理、分布式数据库TiDB及其技术内幕</p>\n</li>\n<li><p>版本管理和自动构建工具：有Svn/Git基础，会使用maven、gradle</p>\n</li>\n<li><p>操作系统：<strong>Ubuntu/Debian/CentOS</strong>。熟悉常用Linux命令和Linux思想</p>\n</li>\n<li><p>Geek精神：非常喜欢学习新技能/钻研技术/探究技术的原理/有Web安全基础/喜欢玩Linux(比如vim、tmux等终端神器)/虽然暂时技能树广度不足，但学习加速度很大 </p>\n</li>\n</ul>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><ul>\n<li><p><strong>网易，精品课研发组，Java开发工程师，2019.02~至今</strong></p>\n<p>​    负责精品课相关业务的研发，MySQL迁移到TiDB。</p>\n</li>\n<li><p><strong>京东数科/京东金融，信贷与对公研发组，Java开发工程师，2018.09~2019.01</strong></p>\n<p>​    负责部门核心项目-企业融资项目开发，熟悉了主要的信用贷流程，包括授信/提款/还款流程开发。</p>\n<p>​    还了解了分布式相关知识，包括分布式调度、分布式存储、技术选型等，并且现在还在持续学习分布式。</p>\n</li>\n</ul>\n<h2 id=\"项目经历\"><a href=\"#项目经历\" class=\"headerlink\" title=\"项目经历\"></a>项目经历</h2><ul>\n<li><p><strong>企业融资系统    /    Java后端开发    /    2018.10~2019.01</strong></p>\n<p>  ​    该系统是我在京东参与的一个企业融资项目，从立项到第三期需求上线，我全程参与，该系统是对B端信贷中台的第一个模型(包括数据模型)。将来在这个系统的基础上会建立一个业务中台。</p>\n<p>  ​    该项目使用了Spring、Spring MVC、Mybatis等框架，MySQL使用的是InnoDB存储引擎，其中通RPC框架解除系统耦合、分发系统压力(个人理解)。</p>\n<p>  ​    在该项目中我学到的技能：RPC框架的使用(即消费者/生产者)、Redis数据结构和使用、InnoDB存储引擎使用的一次实战、分布式系统思维（例如，系统低耦合、高可用等）。</p>\n<p>  ​    开发过程中的思考：数据库索引、唯一索引的设计方式。RPC调用通过JSON传参降低项目模块之间耦合性，提高可扩展性。通过负载均衡、定时任务设计、代码的时间空间复杂度分析等提高效率。包括提款、还款业务的原子性设计问题。</p>\n</li>\n<li><p><strong>学校选课查询系统    /    Java后端开发    /    2017.11~2019.12</strong></p>\n<p>  ​    该项目由天津科技大学教务处委托设计用于学生查询选课信息。</p>\n<p>  ​    项目功能包括:教务处可在 web 端上传 Excel 文件导入数据库。可在另一个web端通过学号、班级号、校区等查询需要选修的课程、课程号等。</p>\n<p>  ​    该项目使用了Spring boot、Spring、Spring MVC、Mybatis等框架集成了后端，使用MySQL数据库，使用索引提高查询速度（只在教务处上传文件时有数据的修改、所以建立索引的熟数量并不会影响学生查询效率），使用Nginx作为反向代理（在本机的开发过程中搭建了伪分布式环境）。</p>\n</li>\n<li><p><strong>基于物联网的化工园区危险源监测系统    /    Android开发        /    2016.10~2016.11</strong> </p>\n<p>​    2015年，8.12塘沽大爆炸事件反映出了化工园区危险源监管不严问题，该系统应运而生。</p>\n<p>​    该项目移动端使用原生Android开发，使用了MQTT协议和github上知名的图表控件MPAndroidChart。</p>\n<p>​    该项目在2016年以大学生创新创业大赛国家级项目立项，申请了软著和专利，并在多个比赛中获奖。</p>\n</li>\n</ul>\n<h2 id=\"个人总结\"><a href=\"#个人总结\" class=\"headerlink\" title=\"个人总结\"></a>个人总结</h2><p>从不认为哪种技术很重要，重要的是思想，或者是解决问题的方法，这些方法的修改/组合可能以后会解决一个或多个问题。一个很简单的例子，TCP的可靠性使其繁重，那么基于UDP的这种可靠性为什么不能在应用层，根据业务定制呢？这里除了应用到TCP实现可靠性的方法，还有一种分层的思想，这种思想的应用我大概也能说一堆。那么如何做到修改/组合这些思想？需要的是软实力/学习力，正好我具备，且在不断学习，而你也需要这样的人。</p>\n"}],"Post":[{"title":"SingletonPattern","date":"2018-12-20T06:21:16.000Z","_content":"\n\n双重检查锁（DCL，即 double-checked locking）\n---\n\n``` java\npublic class Singleton {\n    private volatile static Singleton singleton;\n    private Singleton (){}\n    public static Singleton getSingleton() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n双重检查锁写法中volatile的作用是什么？\n---\n**禁止指令重排序。**(JDK1.5之前volatile不能保证完全禁止指令重排)\n\n\n为什么volatile禁止指令重排序的作用是有必要的？\n---\n（1）singleton = new Singleton()并不是一个原子操作，这条语句会被分为三个步骤\n\n1分配内存空间。\n\n2初始化对象。\n\n3将内存空间的地址赋值给对应的引用。\n\n指令重排序可能导致3在2之前（3不可能在1之前，至于为什么，请思考）。**当cpu执行完3，却未执行完2,恰好有另一个线程执行到第一个非空判断，此时singleton不为null，这时singleton指向的对象未被正确发布。**\n\n在未被正确发布的对象中存在的问题：\nsingleton指向的是一个失效值。（对象只有在构造函数返回后才处于可预知的，真正稳定的状态）\n\n（2） **synchronized保证了变量的可见性**（除此之外，synchronized还有同步功能、保证了同步块内每条语句之间的有序性）。 synchronized代码块中对于共享变量的读取需要从主内存中重新获取，在进入synchronized代码块时并不会保证之前的写操作写入到主内存中，只保证在退出代码块时能将工作内存的数据写入到主内存中。\n\n如果不使用volatile，使用其他方法可不可以？为什么？\n---\n（1）**静态初始化一个对象引用**\n\n单例模式的静态内部类写法\n\n（2）**volatile修饰对象的引用或者使用AtomicReferance**\n\nAtomicReferance保证实例化对象操作的原子性\n\n（3）**final修饰对象的引用**\n\nfinal定义引用时需要初始化。类似于急加载模式，但没必要加final修饰\n\n（4）**将对象引用保存到一个由锁保护的域中**\n\n线程安全库中容器类。或者类库中的其他数据传递机制（例如Future和Exchanger）\n\n（5）**个人认为在第一个if语句执行体和return之间执行任意一个singleton的非静态成员方法**\n\n在执行singleton的非静态成员方法之后，singleton指向的一定是一个完全初始化的对象实例，保证了return返回的一定是一个完全初始化的对象实例\n\n参考资料：\n---\n- Java并发编程实战([Java Concurrency in Practice](https://inbravo.github.io/docs/refer/java-concurrency.pdf)) 3.5安全发布（可精读，最好看英文版）\n- [Java 并发基础之内存模型](https://javadoop.com/post/java-memory-model)（一个高质量的博客，推荐阅读）\n","source":"_posts/SingletonPattern.md","raw":"---\ntitle: SingletonPattern\ndate: 2018-12-20 14:21:16\ncategories: \n\t- Java多线程\n---\n\n\n双重检查锁（DCL，即 double-checked locking）\n---\n\n``` java\npublic class Singleton {\n    private volatile static Singleton singleton;\n    private Singleton (){}\n    public static Singleton getSingleton() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n```\n双重检查锁写法中volatile的作用是什么？\n---\n**禁止指令重排序。**(JDK1.5之前volatile不能保证完全禁止指令重排)\n\n\n为什么volatile禁止指令重排序的作用是有必要的？\n---\n（1）singleton = new Singleton()并不是一个原子操作，这条语句会被分为三个步骤\n\n1分配内存空间。\n\n2初始化对象。\n\n3将内存空间的地址赋值给对应的引用。\n\n指令重排序可能导致3在2之前（3不可能在1之前，至于为什么，请思考）。**当cpu执行完3，却未执行完2,恰好有另一个线程执行到第一个非空判断，此时singleton不为null，这时singleton指向的对象未被正确发布。**\n\n在未被正确发布的对象中存在的问题：\nsingleton指向的是一个失效值。（对象只有在构造函数返回后才处于可预知的，真正稳定的状态）\n\n（2） **synchronized保证了变量的可见性**（除此之外，synchronized还有同步功能、保证了同步块内每条语句之间的有序性）。 synchronized代码块中对于共享变量的读取需要从主内存中重新获取，在进入synchronized代码块时并不会保证之前的写操作写入到主内存中，只保证在退出代码块时能将工作内存的数据写入到主内存中。\n\n如果不使用volatile，使用其他方法可不可以？为什么？\n---\n（1）**静态初始化一个对象引用**\n\n单例模式的静态内部类写法\n\n（2）**volatile修饰对象的引用或者使用AtomicReferance**\n\nAtomicReferance保证实例化对象操作的原子性\n\n（3）**final修饰对象的引用**\n\nfinal定义引用时需要初始化。类似于急加载模式，但没必要加final修饰\n\n（4）**将对象引用保存到一个由锁保护的域中**\n\n线程安全库中容器类。或者类库中的其他数据传递机制（例如Future和Exchanger）\n\n（5）**个人认为在第一个if语句执行体和return之间执行任意一个singleton的非静态成员方法**\n\n在执行singleton的非静态成员方法之后，singleton指向的一定是一个完全初始化的对象实例，保证了return返回的一定是一个完全初始化的对象实例\n\n参考资料：\n---\n- Java并发编程实战([Java Concurrency in Practice](https://inbravo.github.io/docs/refer/java-concurrency.pdf)) 3.5安全发布（可精读，最好看英文版）\n- [Java 并发基础之内存模型](https://javadoop.com/post/java-memory-model)（一个高质量的博客，推荐阅读）\n","slug":"SingletonPattern","published":1,"updated":"2018-12-20T06:24:41.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmn0000dcxv2w124uhw","content":"<h2 id=\"双重检查锁（DCL，即-double-checked-locking）\"><a href=\"#双重检查锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"双重检查锁（DCL，即 double-checked locking）\"></a>双重检查锁（DCL，即 double-checked locking）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双重检查锁写法中volatile的作用是什么？\"><a href=\"#双重检查锁写法中volatile的作用是什么？\" class=\"headerlink\" title=\"双重检查锁写法中volatile的作用是什么？\"></a>双重检查锁写法中volatile的作用是什么？</h2><p><strong>禁止指令重排序。</strong>(JDK1.5之前volatile不能保证完全禁止指令重排)</p>\n<h2 id=\"为什么volatile禁止指令重排序的作用是有必要的？\"><a href=\"#为什么volatile禁止指令重排序的作用是有必要的？\" class=\"headerlink\" title=\"为什么volatile禁止指令重排序的作用是有必要的？\"></a>为什么volatile禁止指令重排序的作用是有必要的？</h2><p>（1）singleton = new Singleton()并不是一个原子操作，这条语句会被分为三个步骤</p>\n<p>1分配内存空间。</p>\n<p>2初始化对象。</p>\n<p>3将内存空间的地址赋值给对应的引用。</p>\n<p>指令重排序可能导致3在2之前（3不可能在1之前，至于为什么，请思考）。<strong>当cpu执行完3，却未执行完2,恰好有另一个线程执行到第一个非空判断，此时singleton不为null，这时singleton指向的对象未被正确发布。</strong></p>\n<p>在未被正确发布的对象中存在的问题：<br>singleton指向的是一个失效值。（对象只有在构造函数返回后才处于可预知的，真正稳定的状态）</p>\n<p>（2） <strong>synchronized保证了变量的可见性</strong>（除此之外，synchronized还有同步功能、保证了同步块内每条语句之间的有序性）。 synchronized代码块中对于共享变量的读取需要从主内存中重新获取，在进入synchronized代码块时并不会保证之前的写操作写入到主内存中，只保证在退出代码块时能将工作内存的数据写入到主内存中。</p>\n<h2 id=\"如果不使用volatile，使用其他方法可不可以？为什么？\"><a href=\"#如果不使用volatile，使用其他方法可不可以？为什么？\" class=\"headerlink\" title=\"如果不使用volatile，使用其他方法可不可以？为什么？\"></a>如果不使用volatile，使用其他方法可不可以？为什么？</h2><p>（1）<strong>静态初始化一个对象引用</strong></p>\n<p>单例模式的静态内部类写法</p>\n<p>（2）<strong>volatile修饰对象的引用或者使用AtomicReferance</strong></p>\n<p>AtomicReferance保证实例化对象操作的原子性</p>\n<p>（3）<strong>final修饰对象的引用</strong></p>\n<p>final定义引用时需要初始化。类似于急加载模式，但没必要加final修饰</p>\n<p>（4）<strong>将对象引用保存到一个由锁保护的域中</strong></p>\n<p>线程安全库中容器类。或者类库中的其他数据传递机制（例如Future和Exchanger）</p>\n<p>（5）<strong>个人认为在第一个if语句执行体和return之间执行任意一个singleton的非静态成员方法</strong></p>\n<p>在执行singleton的非静态成员方法之后，singleton指向的一定是一个完全初始化的对象实例，保证了return返回的一定是一个完全初始化的对象实例</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>Java并发编程实战(<a href=\"https://inbravo.github.io/docs/refer/java-concurrency.pdf\" target=\"_blank\" rel=\"noopener\">Java Concurrency in Practice</a>) 3.5安全发布（可精读，最好看英文版）</li>\n<li><a href=\"https://javadoop.com/post/java-memory-model\" target=\"_blank\" rel=\"noopener\">Java 并发基础之内存模型</a>（一个高质量的博客，推荐阅读）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"双重检查锁（DCL，即-double-checked-locking）\"><a href=\"#双重检查锁（DCL，即-double-checked-locking）\" class=\"headerlink\" title=\"双重检查锁（DCL，即 double-checked locking）\"></a>双重检查锁（DCL，即 double-checked locking）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"双重检查锁写法中volatile的作用是什么？\"><a href=\"#双重检查锁写法中volatile的作用是什么？\" class=\"headerlink\" title=\"双重检查锁写法中volatile的作用是什么？\"></a>双重检查锁写法中volatile的作用是什么？</h2><p><strong>禁止指令重排序。</strong>(JDK1.5之前volatile不能保证完全禁止指令重排)</p>\n<h2 id=\"为什么volatile禁止指令重排序的作用是有必要的？\"><a href=\"#为什么volatile禁止指令重排序的作用是有必要的？\" class=\"headerlink\" title=\"为什么volatile禁止指令重排序的作用是有必要的？\"></a>为什么volatile禁止指令重排序的作用是有必要的？</h2><p>（1）singleton = new Singleton()并不是一个原子操作，这条语句会被分为三个步骤</p>\n<p>1分配内存空间。</p>\n<p>2初始化对象。</p>\n<p>3将内存空间的地址赋值给对应的引用。</p>\n<p>指令重排序可能导致3在2之前（3不可能在1之前，至于为什么，请思考）。<strong>当cpu执行完3，却未执行完2,恰好有另一个线程执行到第一个非空判断，此时singleton不为null，这时singleton指向的对象未被正确发布。</strong></p>\n<p>在未被正确发布的对象中存在的问题：<br>singleton指向的是一个失效值。（对象只有在构造函数返回后才处于可预知的，真正稳定的状态）</p>\n<p>（2） <strong>synchronized保证了变量的可见性</strong>（除此之外，synchronized还有同步功能、保证了同步块内每条语句之间的有序性）。 synchronized代码块中对于共享变量的读取需要从主内存中重新获取，在进入synchronized代码块时并不会保证之前的写操作写入到主内存中，只保证在退出代码块时能将工作内存的数据写入到主内存中。</p>\n<h2 id=\"如果不使用volatile，使用其他方法可不可以？为什么？\"><a href=\"#如果不使用volatile，使用其他方法可不可以？为什么？\" class=\"headerlink\" title=\"如果不使用volatile，使用其他方法可不可以？为什么？\"></a>如果不使用volatile，使用其他方法可不可以？为什么？</h2><p>（1）<strong>静态初始化一个对象引用</strong></p>\n<p>单例模式的静态内部类写法</p>\n<p>（2）<strong>volatile修饰对象的引用或者使用AtomicReferance</strong></p>\n<p>AtomicReferance保证实例化对象操作的原子性</p>\n<p>（3）<strong>final修饰对象的引用</strong></p>\n<p>final定义引用时需要初始化。类似于急加载模式，但没必要加final修饰</p>\n<p>（4）<strong>将对象引用保存到一个由锁保护的域中</strong></p>\n<p>线程安全库中容器类。或者类库中的其他数据传递机制（例如Future和Exchanger）</p>\n<p>（5）<strong>个人认为在第一个if语句执行体和return之间执行任意一个singleton的非静态成员方法</strong></p>\n<p>在执行singleton的非静态成员方法之后，singleton指向的一定是一个完全初始化的对象实例，保证了return返回的一定是一个完全初始化的对象实例</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>Java并发编程实战(<a href=\"https://inbravo.github.io/docs/refer/java-concurrency.pdf\" target=\"_blank\" rel=\"noopener\">Java Concurrency in Practice</a>) 3.5安全发布（可精读，最好看英文版）</li>\n<li><a href=\"https://javadoop.com/post/java-memory-model\" target=\"_blank\" rel=\"noopener\">Java 并发基础之内存模型</a>（一个高质量的博客，推荐阅读）</li>\n</ul>\n"},{"title":"Java内存模型与volatile实现原理","date":"2018-12-20T06:25:50.000Z","_content":"\n一、Java内存模型\n---\n（1）高速缓存的引入解决了CPU与内存的速度差异矛盾，但引入了一个新的问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。\n\nJava内存模型可以理解为在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，是Java跨平台特性的基础。Java内存模型中主内存与硬件主内存类比，工作内存可以类比为CUP高速缓存。\n\n（2）内存间交互操作（原子性，不可再分。除64位的double和long的load、store、read、write分为两次32位原子操作）\n\nlock(锁):对一个变量lock，会清空工作内存中此变量的值\n\nunlock(释放锁):unlock之前，必须先把变量同步回主存\n\nread(读):从主存读取变量，之后必定是load操作\n\nload(加载):工作内存接受读取变量，之前必定是read操作\n\nuse(使用):将变量传递给执行引擎，当JVM遇到一个需要使用变量值的字节码指令时执行该操作\n\nassign(赋值):从执行引擎接收的值，赋给工作内存变量，当JVM遇到一个需要改变值的字节码指令时执行该操作\n\nstore(存储):从工作内存发起回写，之后必定是write操作\n\nwrite(写):主内存接受回写，之前必定是store\n\n（3）Happens-Before原则\n\n1. 程序次序规则\n2. 管程锁定规则\n3. volatile变量规则\n4. 线程启动规则\n5. 线程终止规则\n6. 线程中断规则\n7. 对象终结规则\n8. 传递性\n\n二、volatile实现原理\n---\nvolatile的特性包括：内存可见性和禁止指令重排序。\n\n通过DCL代码理解volatile原理\n\n``` java\npublic static Singleton getSingleton() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n}\n```\nsingleton = new Singleton()的class字节码指令：\n\n\n利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码：\n![](/images/ClassBytecode.png)\n\n**使用volatile修饰**\n![](/images/assembly_1.png)\n\n**不使用volatile修饰**\n![](/images/assembly_2.png)\n\n使用volatile比不使用多了一行lock addl $0x0,(%rsp)。lock前缀相当与一个内存屏障，有三个功能：\n\n1. 重排序时不能把后面的指令重排序到内存屏障之前\n2. 使本CPU的Cache立即写入主存\n3. store和write操作（即写入主存的操作）会使别的CPU的该变量所在的缓存行失效（可能会引起伪共享问题）\n\n参考资料：\n---\n- 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明 著","source":"_posts/Java内存模型与volatile实现原理.md","raw":"---\ntitle: Java内存模型与volatile实现原理\ndate: 2018-12-20 14:25:50\ncategories: \n\t- Java多线程\n---\n\n一、Java内存模型\n---\n（1）高速缓存的引入解决了CPU与内存的速度差异矛盾，但引入了一个新的问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。\n\nJava内存模型可以理解为在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，是Java跨平台特性的基础。Java内存模型中主内存与硬件主内存类比，工作内存可以类比为CUP高速缓存。\n\n（2）内存间交互操作（原子性，不可再分。除64位的double和long的load、store、read、write分为两次32位原子操作）\n\nlock(锁):对一个变量lock，会清空工作内存中此变量的值\n\nunlock(释放锁):unlock之前，必须先把变量同步回主存\n\nread(读):从主存读取变量，之后必定是load操作\n\nload(加载):工作内存接受读取变量，之前必定是read操作\n\nuse(使用):将变量传递给执行引擎，当JVM遇到一个需要使用变量值的字节码指令时执行该操作\n\nassign(赋值):从执行引擎接收的值，赋给工作内存变量，当JVM遇到一个需要改变值的字节码指令时执行该操作\n\nstore(存储):从工作内存发起回写，之后必定是write操作\n\nwrite(写):主内存接受回写，之前必定是store\n\n（3）Happens-Before原则\n\n1. 程序次序规则\n2. 管程锁定规则\n3. volatile变量规则\n4. 线程启动规则\n5. 线程终止规则\n6. 线程中断规则\n7. 对象终结规则\n8. 传递性\n\n二、volatile实现原理\n---\nvolatile的特性包括：内存可见性和禁止指令重排序。\n\n通过DCL代码理解volatile原理\n\n``` java\npublic static Singleton getSingleton() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n}\n```\nsingleton = new Singleton()的class字节码指令：\n\n\n利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码：\n![](/images/ClassBytecode.png)\n\n**使用volatile修饰**\n![](/images/assembly_1.png)\n\n**不使用volatile修饰**\n![](/images/assembly_2.png)\n\n使用volatile比不使用多了一行lock addl $0x0,(%rsp)。lock前缀相当与一个内存屏障，有三个功能：\n\n1. 重排序时不能把后面的指令重排序到内存屏障之前\n2. 使本CPU的Cache立即写入主存\n3. store和write操作（即写入主存的操作）会使别的CPU的该变量所在的缓存行失效（可能会引起伪共享问题）\n\n参考资料：\n---\n- 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明 著","slug":"Java内存模型与volatile实现原理","published":1,"updated":"2018-12-20T07:18:37.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmr0002dcxvz4k6hsg0","content":"<h2 id=\"一、Java内存模型\"><a href=\"#一、Java内存模型\" class=\"headerlink\" title=\"一、Java内存模型\"></a>一、Java内存模型</h2><p>（1）高速缓存的引入解决了CPU与内存的速度差异矛盾，但引入了一个新的问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。</p>\n<p>Java内存模型可以理解为在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，是Java跨平台特性的基础。Java内存模型中主内存与硬件主内存类比，工作内存可以类比为CUP高速缓存。</p>\n<p>（2）内存间交互操作（原子性，不可再分。除64位的double和long的load、store、read、write分为两次32位原子操作）</p>\n<p>lock(锁):对一个变量lock，会清空工作内存中此变量的值</p>\n<p>unlock(释放锁):unlock之前，必须先把变量同步回主存</p>\n<p>read(读):从主存读取变量，之后必定是load操作</p>\n<p>load(加载):工作内存接受读取变量，之前必定是read操作</p>\n<p>use(使用):将变量传递给执行引擎，当JVM遇到一个需要使用变量值的字节码指令时执行该操作</p>\n<p>assign(赋值):从执行引擎接收的值，赋给工作内存变量，当JVM遇到一个需要改变值的字节码指令时执行该操作</p>\n<p>store(存储):从工作内存发起回写，之后必定是write操作</p>\n<p>write(写):主内存接受回写，之前必定是store</p>\n<p>（3）Happens-Before原则</p>\n<ol>\n<li>程序次序规则</li>\n<li>管程锁定规则</li>\n<li>volatile变量规则</li>\n<li>线程启动规则</li>\n<li>线程终止规则</li>\n<li>线程中断规则</li>\n<li>对象终结规则</li>\n<li>传递性</li>\n</ol>\n<h2 id=\"二、volatile实现原理\"><a href=\"#二、volatile实现原理\" class=\"headerlink\" title=\"二、volatile实现原理\"></a>二、volatile实现原理</h2><p>volatile的特性包括：内存可见性和禁止指令重排序。</p>\n<p>通过DCL代码理解volatile原理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>singleton = new Singleton()的class字节码指令：</p>\n<p>利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码：<br><img src=\"/images/ClassBytecode.png\" alt=\"\"></p>\n<p><strong>使用volatile修饰</strong><br><img src=\"/images/assembly_1.png\" alt=\"\"></p>\n<p><strong>不使用volatile修饰</strong><br><img src=\"/images/assembly_2.png\" alt=\"\"></p>\n<p>使用volatile比不使用多了一行lock addl $0x0,(%rsp)。lock前缀相当与一个内存屏障，有三个功能：</p>\n<ol>\n<li>重排序时不能把后面的指令重排序到内存屏障之前</li>\n<li>使本CPU的Cache立即写入主存</li>\n<li>store和write操作（即写入主存的操作）会使别的CPU的该变量所在的缓存行失效（可能会引起伪共享问题）</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明 著</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、Java内存模型\"><a href=\"#一、Java内存模型\" class=\"headerlink\" title=\"一、Java内存模型\"></a>一、Java内存模型</h2><p>（1）高速缓存的引入解决了CPU与内存的速度差异矛盾，但引入了一个新的问题：缓存一致性（Cache Coherence）。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。</p>\n<p>Java内存模型可以理解为在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。Java内存模型屏蔽了各种硬件和操作系统的内存访问差异，是Java跨平台特性的基础。Java内存模型中主内存与硬件主内存类比，工作内存可以类比为CUP高速缓存。</p>\n<p>（2）内存间交互操作（原子性，不可再分。除64位的double和long的load、store、read、write分为两次32位原子操作）</p>\n<p>lock(锁):对一个变量lock，会清空工作内存中此变量的值</p>\n<p>unlock(释放锁):unlock之前，必须先把变量同步回主存</p>\n<p>read(读):从主存读取变量，之后必定是load操作</p>\n<p>load(加载):工作内存接受读取变量，之前必定是read操作</p>\n<p>use(使用):将变量传递给执行引擎，当JVM遇到一个需要使用变量值的字节码指令时执行该操作</p>\n<p>assign(赋值):从执行引擎接收的值，赋给工作内存变量，当JVM遇到一个需要改变值的字节码指令时执行该操作</p>\n<p>store(存储):从工作内存发起回写，之后必定是write操作</p>\n<p>write(写):主内存接受回写，之前必定是store</p>\n<p>（3）Happens-Before原则</p>\n<ol>\n<li>程序次序规则</li>\n<li>管程锁定规则</li>\n<li>volatile变量规则</li>\n<li>线程启动规则</li>\n<li>线程终止规则</li>\n<li>线程中断规则</li>\n<li>对象终结规则</li>\n<li>传递性</li>\n</ol>\n<h2 id=\"二、volatile实现原理\"><a href=\"#二、volatile实现原理\" class=\"headerlink\" title=\"二、volatile实现原理\"></a>二、volatile实现原理</h2><p>volatile的特性包括：内存可见性和禁止指令重排序。</p>\n<p>通过DCL代码理解volatile原理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>singleton = new Singleton()的class字节码指令：</p>\n<p>利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码：<br><img src=\"/images/ClassBytecode.png\" alt=\"\"></p>\n<p><strong>使用volatile修饰</strong><br><img src=\"/images/assembly_1.png\" alt=\"\"></p>\n<p><strong>不使用volatile修饰</strong><br><img src=\"/images/assembly_2.png\" alt=\"\"></p>\n<p>使用volatile比不使用多了一行lock addl $0x0,(%rsp)。lock前缀相当与一个内存屏障，有三个功能：</p>\n<ol>\n<li>重排序时不能把后面的指令重排序到内存屏障之前</li>\n<li>使本CPU的Cache立即写入主存</li>\n<li>store和write操作（即写入主存的操作）会使别的CPU的该变量所在的缓存行失效（可能会引起伪共享问题）</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明 著</li>\n</ul>\n"},{"title":"InnoDB如何保证事务四大特性","date":"2018-12-20T06:43:01.000Z","_content":"\n事务的四大特性\n---\n\n![](/images/acid.png)\n\n1. 原子性(Atomicity)：原子性指整个数据库事务是不可分割的工作单位。事务中所有的数据库操作，要么全部提交成功，要么全部失败回滚。\n\n2. 一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n3. 隔离性(Isolation)：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。\n\n4. 持久性(Durability)：事务一旦提交，其结果是永久性的，即使发生宕机等故障，数据库也能将数据恢复。\n\n并发一致性问题\n---\n1. 丢失修改\n2. 脏读：读到未提交的数据\n3. 不可重复读：读到已提交的数据；同样的条件，第一次与第二次读的值不同。\n4. 幻读：同样的条件，第一次与第二次读出来的记录不同。\n\n隔离级别\n---\n\n1. READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其它事务也是可见的。任何操作都不加锁。\n\n2. READ COMMITTED（读已提交）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。数据的读取不加锁，但数据的写入、修改和删除都加锁。\n\n3. REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同样数据的结果是一样的。MVCC机制让数据变得可重复读。\n\n4. SERIALIZABLE（可串行化）：强制事务串行执行。全部操作加悲观锁。读加共享锁，写加排他锁。\n\nRedo log\n---\n重做日志由两部分组成：内存中重做日志缓冲和重做日志文件。\n\n当事务提交时，必须先将该事务的所有日志写入到重做日志进行持久化。在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，来确保日志写入磁盘。由于fsync操作取决于磁盘，因此磁盘性能决定了事务提交的性能。\n\n参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交时必须调用一次fsync操作。参数为0表示事务提交时不进行写入重做日志操作，而在master thread中每秒进行一次写入重做日志，并执行fsync操作。参数为2表示事务提交时将重做日志写入重做日志文件，但仅写入缓存中，不进行fsync操作。\n\nUndo log\n---\n如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用undo信息将数据回滚。undo存放在数据库内部的undo段(undo segment)中。\n\n当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。如果是INSERT，会执行DELETE，反之同理。所以，undo是逻辑日志而不是物理恢复。数据结构和页本身在回滚之后可能大不相同。不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。\n\nInnoDB中的锁\n---\n**行级锁**\n\n- 共享锁(S Lock,Shared)，允许事务读一行数据\n- 排他锁(X Lock,Exclusive)，允许事务删除或更新一行数据\n一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n\n一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n兼容关系\n\n\n| -      | X      | S     |\n| ------ |:------:| -----:|\n|   X    |   NO   |   NO  |\n|   S    |   NO   |   YES |\n\n\n**表级锁：意向锁(Intention Lock)**\n\n\n- 意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁\n- 意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁\n\n任意IS/IX锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁.\nS锁只与S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其它事务可以已经获得对表或者表中的行的S锁。\n\n兼容关系\n\n| -      | X      | IX    | S     | IS    |\n| ------ |:------:| -----:| -----:| -----:|\n|   X    |   NO   |   NO  |   NO  |   NO  |\n|   IX   |   NO   |   YES |   NO  |   YES |\n|   S    |   NO   |   NO  |  YES  |  YES  |\n|   IS   |   NO   |   YES |  YES  |  YES  |\n\n\n**一致性非锁定读**\n\n一致性非锁定读：如果一条记录被加了X锁，其他事务读取这条记录时，不会等待行上的锁释放，InnoDB存储引擎会去读取行的一个快照数据。\n\n一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVCC)。\n\nMVCC：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\nREAD COMMITTED事务隔离级别时，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。\nREPEATABLE READ事务隔离级别时，对于快照数据，非一致性读总是读取事务开始时的行数据版本。\n\n**一致性锁定读**\n\n显示地对数据库读取操作进行加锁。\n\nSELECT … FOR UPDATE\n\nSELECT … LOCK IN SHARE MODE\n\n**行锁的三种算法**\n\nInnoDB存储引擎有三种行锁的算法。\n\n1. Record Lock：单个行记录上的锁。锁住索引记录（若建表时无索引，使用隐式的主键进行锁定）\n2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。\n3. Next-Key Lock：是Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身(区间前开后闭)。\n\nInnoDB查询时采用Next-Key Locking，解决了幻读。\n\nInnoDB如何保证原子性(Atomicity)？\n---\n在事务里任何对数据的修改都会写一个undo log，然后进行数据的修改，如果出现错误，存储引擎会利用undo log的备份数据恢复到事务开始之前的状态。\n\nInnoDB如何保证一致性(Consistency)？\n---\n事务的原子性和隔离性保证了数据的一致性\n\nInnoDB如何保证隔离性(Isolation)？\n---\nInnoDB的默认隔离级别REPEATABLE READ + Next-Key Locking，保证了数据库的隔离性，不出现并发一致性问题，且理论上效率高于SERIALIZABLE隔离级别。\n\nInnoDB如何保证持久性(Durability)？\n---\nInnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试通过redo log进行恢复操作。\n\n参考资料：\n---\n\n- 《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著\n- [谈谈MySQL InnoDB存储引擎事务的ACID特性](http://benjaminwhx.com/2018/04/25/%E8%B0%88%E8%B0%88MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7/)","source":"_posts/InnoDB如何保证事务四大特性.md","raw":"---\ntitle: InnoDB如何保证事务四大特性\ndate: 2018-12-20 14:43:01\ncategories: \n\t- 数据库\n---\n\n事务的四大特性\n---\n\n![](/images/acid.png)\n\n1. 原子性(Atomicity)：原子性指整个数据库事务是不可分割的工作单位。事务中所有的数据库操作，要么全部提交成功，要么全部失败回滚。\n\n2. 一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。\n\n3. 隔离性(Isolation)：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。\n\n4. 持久性(Durability)：事务一旦提交，其结果是永久性的，即使发生宕机等故障，数据库也能将数据恢复。\n\n并发一致性问题\n---\n1. 丢失修改\n2. 脏读：读到未提交的数据\n3. 不可重复读：读到已提交的数据；同样的条件，第一次与第二次读的值不同。\n4. 幻读：同样的条件，第一次与第二次读出来的记录不同。\n\n隔离级别\n---\n\n1. READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其它事务也是可见的。任何操作都不加锁。\n\n2. READ COMMITTED（读已提交）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。数据的读取不加锁，但数据的写入、修改和删除都加锁。\n\n3. REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同样数据的结果是一样的。MVCC机制让数据变得可重复读。\n\n4. SERIALIZABLE（可串行化）：强制事务串行执行。全部操作加悲观锁。读加共享锁，写加排他锁。\n\nRedo log\n---\n重做日志由两部分组成：内存中重做日志缓冲和重做日志文件。\n\n当事务提交时，必须先将该事务的所有日志写入到重做日志进行持久化。在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，来确保日志写入磁盘。由于fsync操作取决于磁盘，因此磁盘性能决定了事务提交的性能。\n\n参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交时必须调用一次fsync操作。参数为0表示事务提交时不进行写入重做日志操作，而在master thread中每秒进行一次写入重做日志，并执行fsync操作。参数为2表示事务提交时将重做日志写入重做日志文件，但仅写入缓存中，不进行fsync操作。\n\nUndo log\n---\n如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用undo信息将数据回滚。undo存放在数据库内部的undo段(undo segment)中。\n\n当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。如果是INSERT，会执行DELETE，反之同理。所以，undo是逻辑日志而不是物理恢复。数据结构和页本身在回滚之后可能大不相同。不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。\n\nInnoDB中的锁\n---\n**行级锁**\n\n- 共享锁(S Lock,Shared)，允许事务读一行数据\n- 排他锁(X Lock,Exclusive)，允许事务删除或更新一行数据\n一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。\n\n一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。\n\n兼容关系\n\n\n| -      | X      | S     |\n| ------ |:------:| -----:|\n|   X    |   NO   |   NO  |\n|   S    |   NO   |   YES |\n\n\n**表级锁：意向锁(Intention Lock)**\n\n\n- 意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁\n- 意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁\n\n任意IS/IX锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁.\nS锁只与S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其它事务可以已经获得对表或者表中的行的S锁。\n\n兼容关系\n\n| -      | X      | IX    | S     | IS    |\n| ------ |:------:| -----:| -----:| -----:|\n|   X    |   NO   |   NO  |   NO  |   NO  |\n|   IX   |   NO   |   YES |   NO  |   YES |\n|   S    |   NO   |   NO  |  YES  |  YES  |\n|   IS   |   NO   |   YES |  YES  |  YES  |\n\n\n**一致性非锁定读**\n\n一致性非锁定读：如果一条记录被加了X锁，其他事务读取这条记录时，不会等待行上的锁释放，InnoDB存储引擎会去读取行的一个快照数据。\n\n一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVCC)。\n\nMVCC：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n\nREAD COMMITTED事务隔离级别时，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。\nREPEATABLE READ事务隔离级别时，对于快照数据，非一致性读总是读取事务开始时的行数据版本。\n\n**一致性锁定读**\n\n显示地对数据库读取操作进行加锁。\n\nSELECT … FOR UPDATE\n\nSELECT … LOCK IN SHARE MODE\n\n**行锁的三种算法**\n\nInnoDB存储引擎有三种行锁的算法。\n\n1. Record Lock：单个行记录上的锁。锁住索引记录（若建表时无索引，使用隐式的主键进行锁定）\n2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。\n3. Next-Key Lock：是Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身(区间前开后闭)。\n\nInnoDB查询时采用Next-Key Locking，解决了幻读。\n\nInnoDB如何保证原子性(Atomicity)？\n---\n在事务里任何对数据的修改都会写一个undo log，然后进行数据的修改，如果出现错误，存储引擎会利用undo log的备份数据恢复到事务开始之前的状态。\n\nInnoDB如何保证一致性(Consistency)？\n---\n事务的原子性和隔离性保证了数据的一致性\n\nInnoDB如何保证隔离性(Isolation)？\n---\nInnoDB的默认隔离级别REPEATABLE READ + Next-Key Locking，保证了数据库的隔离性，不出现并发一致性问题，且理论上效率高于SERIALIZABLE隔离级别。\n\nInnoDB如何保证持久性(Durability)？\n---\nInnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试通过redo log进行恢复操作。\n\n参考资料：\n---\n\n- 《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著\n- [谈谈MySQL InnoDB存储引擎事务的ACID特性](http://benjaminwhx.com/2018/04/25/%E8%B0%88%E8%B0%88MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7/)","slug":"InnoDB如何保证事务四大特性","published":1,"updated":"2018-12-20T07:18:17.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmu0005dcxvnsi7e7ib","content":"<h2 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h2><p><img src=\"/images/acid.png\" alt=\"\"></p>\n<ol>\n<li><p>原子性(Atomicity)：原子性指整个数据库事务是不可分割的工作单位。事务中所有的数据库操作，要么全部提交成功，要么全部失败回滚。</p>\n</li>\n<li><p>一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性(Isolation)：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。</p>\n</li>\n<li><p>持久性(Durability)：事务一旦提交，其结果是永久性的，即使发生宕机等故障，数据库也能将数据恢复。</p>\n</li>\n</ol>\n<h2 id=\"并发一致性问题\"><a href=\"#并发一致性问题\" class=\"headerlink\" title=\"并发一致性问题\"></a>并发一致性问题</h2><ol>\n<li>丢失修改</li>\n<li>脏读：读到未提交的数据</li>\n<li>不可重复读：读到已提交的数据；同样的条件，第一次与第二次读的值不同。</li>\n<li>幻读：同样的条件，第一次与第二次读出来的记录不同。</li>\n</ol>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><ol>\n<li><p>READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其它事务也是可见的。任何操作都不加锁。</p>\n</li>\n<li><p>READ COMMITTED（读已提交）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。数据的读取不加锁，但数据的写入、修改和删除都加锁。</p>\n</li>\n<li><p>REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同样数据的结果是一样的。MVCC机制让数据变得可重复读。</p>\n</li>\n<li><p>SERIALIZABLE（可串行化）：强制事务串行执行。全部操作加悲观锁。读加共享锁，写加排他锁。</p>\n</li>\n</ol>\n<h2 id=\"Redo-log\"><a href=\"#Redo-log\" class=\"headerlink\" title=\"Redo log\"></a>Redo log</h2><p>重做日志由两部分组成：内存中重做日志缓冲和重做日志文件。</p>\n<p>当事务提交时，必须先将该事务的所有日志写入到重做日志进行持久化。在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，来确保日志写入磁盘。由于fsync操作取决于磁盘，因此磁盘性能决定了事务提交的性能。</p>\n<p>参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交时必须调用一次fsync操作。参数为0表示事务提交时不进行写入重做日志操作，而在master thread中每秒进行一次写入重做日志，并执行fsync操作。参数为2表示事务提交时将重做日志写入重做日志文件，但仅写入缓存中，不进行fsync操作。</p>\n<h2 id=\"Undo-log\"><a href=\"#Undo-log\" class=\"headerlink\" title=\"Undo log\"></a>Undo log</h2><p>如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用undo信息将数据回滚。undo存放在数据库内部的undo段(undo segment)中。</p>\n<p>当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。如果是INSERT，会执行DELETE，反之同理。所以，undo是逻辑日志而不是物理恢复。数据结构和页本身在回滚之后可能大不相同。不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>\n<h2 id=\"InnoDB中的锁\"><a href=\"#InnoDB中的锁\" class=\"headerlink\" title=\"InnoDB中的锁\"></a>InnoDB中的锁</h2><p><strong>行级锁</strong></p>\n<ul>\n<li>共享锁(S Lock,Shared)，允许事务读一行数据</li>\n<li>排他锁(X Lock,Exclusive)，允许事务删除或更新一行数据<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n</ul>\n<p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p>\n<p>兼容关系</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">X</th>\n<th style=\"text-align:right\">S</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n</tr>\n<tr>\n<td>S</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n</tbody>\n</table>\n<p><strong>表级锁：意向锁(Intention Lock)</strong></p>\n<ul>\n<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>\n<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>\n</ul>\n<p>任意IS/IX锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁.<br>S锁只与S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其它事务可以已经获得对表或者表中的行的S锁。</p>\n<p>兼容关系</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">X</th>\n<th style=\"text-align:right\">IX</th>\n<th style=\"text-align:right\">S</th>\n<th style=\"text-align:right\">IS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">NO</td>\n</tr>\n<tr>\n<td>IX</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n<tr>\n<td>S</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n<tr>\n<td>IS</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一致性非锁定读</strong></p>\n<p>一致性非锁定读：如果一条记录被加了X锁，其他事务读取这条记录时，不会等待行上的锁释放，InnoDB存储引擎会去读取行的一个快照数据。</p>\n<p>一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVCC)。</p>\n<p>MVCC：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>\n<p>READ COMMITTED事务隔离级别时，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。<br>REPEATABLE READ事务隔离级别时，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>\n<p><strong>一致性锁定读</strong></p>\n<p>显示地对数据库读取操作进行加锁。</p>\n<p>SELECT … FOR UPDATE</p>\n<p>SELECT … LOCK IN SHARE MODE</p>\n<p><strong>行锁的三种算法</strong></p>\n<p>InnoDB存储引擎有三种行锁的算法。</p>\n<ol>\n<li>Record Lock：单个行记录上的锁。锁住索引记录（若建表时无索引，使用隐式的主键进行锁定）</li>\n<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li>\n<li>Next-Key Lock：是Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身(区间前开后闭)。</li>\n</ol>\n<p>InnoDB查询时采用Next-Key Locking，解决了幻读。</p>\n<h2 id=\"InnoDB如何保证原子性-Atomicity-？\"><a href=\"#InnoDB如何保证原子性-Atomicity-？\" class=\"headerlink\" title=\"InnoDB如何保证原子性(Atomicity)？\"></a>InnoDB如何保证原子性(Atomicity)？</h2><p>在事务里任何对数据的修改都会写一个undo log，然后进行数据的修改，如果出现错误，存储引擎会利用undo log的备份数据恢复到事务开始之前的状态。</p>\n<h2 id=\"InnoDB如何保证一致性-Consistency-？\"><a href=\"#InnoDB如何保证一致性-Consistency-？\" class=\"headerlink\" title=\"InnoDB如何保证一致性(Consistency)？\"></a>InnoDB如何保证一致性(Consistency)？</h2><p>事务的原子性和隔离性保证了数据的一致性</p>\n<h2 id=\"InnoDB如何保证隔离性-Isolation-？\"><a href=\"#InnoDB如何保证隔离性-Isolation-？\" class=\"headerlink\" title=\"InnoDB如何保证隔离性(Isolation)？\"></a>InnoDB如何保证隔离性(Isolation)？</h2><p>InnoDB的默认隔离级别REPEATABLE READ + Next-Key Locking，保证了数据库的隔离性，不出现并发一致性问题，且理论上效率高于SERIALIZABLE隔离级别。</p>\n<h2 id=\"InnoDB如何保证持久性-Durability-？\"><a href=\"#InnoDB如何保证持久性-Durability-？\" class=\"headerlink\" title=\"InnoDB如何保证持久性(Durability)？\"></a>InnoDB如何保证持久性(Durability)？</h2><p>InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试通过redo log进行恢复操作。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著</li>\n<li><a href=\"http://benjaminwhx.com/2018/04/25/%E8%B0%88%E8%B0%88MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">谈谈MySQL InnoDB存储引擎事务的ACID特性</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h2><p><img src=\"/images/acid.png\" alt=\"\"></p>\n<ol>\n<li><p>原子性(Atomicity)：原子性指整个数据库事务是不可分割的工作单位。事务中所有的数据库操作，要么全部提交成功，要么全部失败回滚。</p>\n</li>\n<li><p>一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。</p>\n</li>\n<li><p>隔离性(Isolation)：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。</p>\n</li>\n<li><p>持久性(Durability)：事务一旦提交，其结果是永久性的，即使发生宕机等故障，数据库也能将数据恢复。</p>\n</li>\n</ol>\n<h2 id=\"并发一致性问题\"><a href=\"#并发一致性问题\" class=\"headerlink\" title=\"并发一致性问题\"></a>并发一致性问题</h2><ol>\n<li>丢失修改</li>\n<li>脏读：读到未提交的数据</li>\n<li>不可重复读：读到已提交的数据；同样的条件，第一次与第二次读的值不同。</li>\n<li>幻读：同样的条件，第一次与第二次读出来的记录不同。</li>\n</ol>\n<h2 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h2><ol>\n<li><p>READ UNCOMMITTED（读未提交）：事务中的修改，即使没有提交，对其它事务也是可见的。任何操作都不加锁。</p>\n</li>\n<li><p>READ COMMITTED（读已提交）：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。数据的读取不加锁，但数据的写入、修改和删除都加锁。</p>\n</li>\n<li><p>REPEATABLE READ（可重复读）：保证在同一个事务中多次读取同样数据的结果是一样的。MVCC机制让数据变得可重复读。</p>\n</li>\n<li><p>SERIALIZABLE（可串行化）：强制事务串行执行。全部操作加悲观锁。读加共享锁，写加排他锁。</p>\n</li>\n</ol>\n<h2 id=\"Redo-log\"><a href=\"#Redo-log\" class=\"headerlink\" title=\"Redo log\"></a>Redo log</h2><p>重做日志由两部分组成：内存中重做日志缓冲和重做日志文件。</p>\n<p>当事务提交时，必须先将该事务的所有日志写入到重做日志进行持久化。在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作，来确保日志写入磁盘。由于fsync操作取决于磁盘，因此磁盘性能决定了事务提交的性能。</p>\n<p>参数innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。该参数默认值为1，表示事务提交时必须调用一次fsync操作。参数为0表示事务提交时不进行写入重做日志操作，而在master thread中每秒进行一次写入重做日志，并执行fsync操作。参数为2表示事务提交时将重做日志写入重做日志文件，但仅写入缓存中，不进行fsync操作。</p>\n<h2 id=\"Undo-log\"><a href=\"#Undo-log\" class=\"headerlink\" title=\"Undo log\"></a>Undo log</h2><p>如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用undo信息将数据回滚。undo存放在数据库内部的undo段(undo segment)中。</p>\n<p>当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个UPDATE，会执行一个相反的UPDATE，将修改前的行放回去。如果是INSERT，会执行DELETE，反之同理。所以，undo是逻辑日志而不是物理恢复。数据结构和页本身在回滚之后可能大不相同。不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p>\n<h2 id=\"InnoDB中的锁\"><a href=\"#InnoDB中的锁\" class=\"headerlink\" title=\"InnoDB中的锁\"></a>InnoDB中的锁</h2><p><strong>行级锁</strong></p>\n<ul>\n<li>共享锁(S Lock,Shared)，允许事务读一行数据</li>\n<li>排他锁(X Lock,Exclusive)，允许事务删除或更新一行数据<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>\n</ul>\n<p>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p>\n<p>兼容关系</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">X</th>\n<th style=\"text-align:right\">S</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n</tr>\n<tr>\n<td>S</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n</tbody>\n</table>\n<p><strong>表级锁：意向锁(Intention Lock)</strong></p>\n<ul>\n<li>意向共享锁(IS Lock)，事务想要获得一张表中某几行的共享锁</li>\n<li>意向排他锁(IX Lock)，事务想要获得一张表中某几行的排他锁</li>\n</ul>\n<p>任意IS/IX锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁.<br>S锁只与S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其它事务可以已经获得对表或者表中的行的S锁。</p>\n<p>兼容关系</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th style=\"text-align:center\">X</th>\n<th style=\"text-align:right\">IX</th>\n<th style=\"text-align:right\">S</th>\n<th style=\"text-align:right\">IS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>X</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">NO</td>\n</tr>\n<tr>\n<td>IX</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n<tr>\n<td>S</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n<tr>\n<td>IS</td>\n<td style=\"text-align:center\">NO</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n<td style=\"text-align:right\">YES</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一致性非锁定读</strong></p>\n<p>一致性非锁定读：如果一条记录被加了X锁，其他事务读取这条记录时，不会等待行上的锁释放，InnoDB存储引擎会去读取行的一个快照数据。</p>\n<p>一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制(Multi Version Concurrency Control, MVCC)。</p>\n<p>MVCC：为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>\n<p>READ COMMITTED事务隔离级别时，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。<br>REPEATABLE READ事务隔离级别时，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</p>\n<p><strong>一致性锁定读</strong></p>\n<p>显示地对数据库读取操作进行加锁。</p>\n<p>SELECT … FOR UPDATE</p>\n<p>SELECT … LOCK IN SHARE MODE</p>\n<p><strong>行锁的三种算法</strong></p>\n<p>InnoDB存储引擎有三种行锁的算法。</p>\n<ol>\n<li>Record Lock：单个行记录上的锁。锁住索引记录（若建表时无索引，使用隐式的主键进行锁定）</li>\n<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li>\n<li>Next-Key Lock：是Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身(区间前开后闭)。</li>\n</ol>\n<p>InnoDB查询时采用Next-Key Locking，解决了幻读。</p>\n<h2 id=\"InnoDB如何保证原子性-Atomicity-？\"><a href=\"#InnoDB如何保证原子性-Atomicity-？\" class=\"headerlink\" title=\"InnoDB如何保证原子性(Atomicity)？\"></a>InnoDB如何保证原子性(Atomicity)？</h2><p>在事务里任何对数据的修改都会写一个undo log，然后进行数据的修改，如果出现错误，存储引擎会利用undo log的备份数据恢复到事务开始之前的状态。</p>\n<h2 id=\"InnoDB如何保证一致性-Consistency-？\"><a href=\"#InnoDB如何保证一致性-Consistency-？\" class=\"headerlink\" title=\"InnoDB如何保证一致性(Consistency)？\"></a>InnoDB如何保证一致性(Consistency)？</h2><p>事务的原子性和隔离性保证了数据的一致性</p>\n<h2 id=\"InnoDB如何保证隔离性-Isolation-？\"><a href=\"#InnoDB如何保证隔离性-Isolation-？\" class=\"headerlink\" title=\"InnoDB如何保证隔离性(Isolation)？\"></a>InnoDB如何保证隔离性(Isolation)？</h2><p>InnoDB的默认隔离级别REPEATABLE READ + Next-Key Locking，保证了数据库的隔离性，不出现并发一致性问题，且理论上效率高于SERIALIZABLE隔离级别。</p>\n<h2 id=\"InnoDB如何保证持久性-Durability-？\"><a href=\"#InnoDB如何保证持久性-Durability-？\" class=\"headerlink\" title=\"InnoDB如何保证持久性(Durability)？\"></a>InnoDB如何保证持久性(Durability)？</h2><p>InnoDB存储引擎在启动时不管上次数据库运行时是否正常关闭，都会尝试通过redo log进行恢复操作。</p>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著</li>\n<li><a href=\"http://benjaminwhx.com/2018/04/25/%E8%B0%88%E8%B0%88MySQL-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">谈谈MySQL InnoDB存储引擎事务的ACID特性</a></li>\n</ul>\n"},{"title":"InnoDB索引详解","date":"2018-12-20T06:41:21.000Z","_content":"\n> B树(Balance Tree)本质属于一颗平衡树。\n\n> B+树是基于B树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n为什么使用B+树？\n---\n（1）B+树比起二叉树的优势\n\n索引以索引文件的形式存储的磁盘上，每次读取节点就会进行一次磁盘IO操作，获取一个页（操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据），而B+树“矮胖”的特点可以减少IO操作次数，以提升效率。\n\n（2）B+树为什么比B树更合适？\n\n1. B+树非叶子节点只包含关键字，每个磁盘块可以存储更多的关键字；而B树非叶子节点还包含数据，所以B+树中每个磁盘块可以存储更多关键字，更矮胖，IO次数更少。\n2. B+树叶子节点存储全部数据，数据以指针相连形成链表；而B树非叶子节点的数据未存储在叶子节点上。所以B+树的范围查找效率比B树更高。\n3. B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，所以B+树查找更稳定（并不慢）。\n\nB+树索引的分裂\n---\n1. 按照原页中点分裂，再将数据插入。（随机插入）\n2. 分裂操作优化：不移动原页，将数据插入到新页中。（递增递减插入）\n\n[从MySQL Bug#67718浅谈B+树索引的分裂优化](http://allan.li/mysql-index-optimize/)\n\nB+树索引的管理\n---\n创建索引（联合索引）\n\n>ALTER TABLE table_name ADD INDEX index_name (column_list1,column_list2);\n\n>ALTER TABLE table_name ADD UNIQUE (column_list1,column_list2);\n\n>ALTER TABLE table_name ADD PRIMARY KEY (column_list1,column_list2);\n\n>CREATE INDEX index_name ON table_name (column_list1,column_list2);\n\n>CREATE UNIQUE INDEX index_name ON table_name (column_list1,column_list2);\n\n删除索引\n\n>DROP INDEX index_name ON talbe_name;\n\n>ALTER TABLE table_name DROP INDEX index_name;\n\n>ALTER TABLE table_name DROP PRIMARY KEY;\n\n查看索引\n\n>SHOW INDEX FROM talbe_name;\n\n>SHOW KEYS FROM talbe_name;\n\n- Table： 表的名称\n- Non_unique： 非唯一，如果索引不能包括重复词，则为0。如果可以，则为1\n- Key_name： 索引名称，可以用这个名称DROP INDEX\n- Seq_in_index： 索引中该列的位置（常见于联合索引）\n- Column_name： 索引列的名称\n- Collation： 索引存储方式。A：B+树索引，有序。NULL：Hash索引\n- Cardinality： 索引中唯一值的数目的估计值\n- Sub_part： 是否为列的部分被索引，若显示100，则表示只对该列的前100个字符索引。如果显示NULL，则整个列被索引\n- Packed： 关键字如何被压缩\n- Null： 是否为null\n- Index_type： 索引的类型\n- Comment： 注释\n\nB+树索引的查询性能优化\n---\n（1） 使用 Explain 进行分析\n\n[MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)\n\n（2）\n\nSELECT * FROM talbe_name USE INDEX(index_name) WHERE();\n\nUSE INDEX(index_name) 建议优化器使用索引\n\nFORCE INDEX(index_name) 强制优化器使用索引\n\n（3）索引失效的解决方法以及索引使用的注意点\n\n1. 一般在where和join中出现的列需要建立索引\n2. MySQL只对<、<=、=、>、>=、BETWEEN、IN和部分情况下的LIKE才会使用索引\n3. 查询条件包含OR，且有不含索引的列时，索引失效\n4. 联合索引，不符合最左前缀原则，索引失效\n5. LIKE模糊查询以%开头，索引失效\n6. 列类型是字符串，WHERE时不用引号，索引失效\n7. 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效\n\n全文检索\n---\n全文索引(Full-Text Search)是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。\n\n（1）倒排索引（辅助表）\n\n- inverted file index {单词,单词所在文档的ID}\n- full inverted index {单词,(单词所在的文档ID,在具体文档中的位置)}\n\n参考资料：\n---\n- 《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著\n- [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)\n- [从MySQL Bug#67718浅谈B+树索引的分裂优化](http://allan.li/mysql-index-optimize/)","source":"_posts/InnoDB索引详解.md","raw":"---\ntitle: InnoDB索引详解\ndate: 2018-12-20 14:41:21\ncategories: \n\t- 数据库\n---\n\n> B树(Balance Tree)本质属于一颗平衡树。\n\n> B+树是基于B树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n\n为什么使用B+树？\n---\n（1）B+树比起二叉树的优势\n\n索引以索引文件的形式存储的磁盘上，每次读取节点就会进行一次磁盘IO操作，获取一个页（操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据），而B+树“矮胖”的特点可以减少IO操作次数，以提升效率。\n\n（2）B+树为什么比B树更合适？\n\n1. B+树非叶子节点只包含关键字，每个磁盘块可以存储更多的关键字；而B树非叶子节点还包含数据，所以B+树中每个磁盘块可以存储更多关键字，更矮胖，IO次数更少。\n2. B+树叶子节点存储全部数据，数据以指针相连形成链表；而B树非叶子节点的数据未存储在叶子节点上。所以B+树的范围查找效率比B树更高。\n3. B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，所以B+树查找更稳定（并不慢）。\n\nB+树索引的分裂\n---\n1. 按照原页中点分裂，再将数据插入。（随机插入）\n2. 分裂操作优化：不移动原页，将数据插入到新页中。（递增递减插入）\n\n[从MySQL Bug#67718浅谈B+树索引的分裂优化](http://allan.li/mysql-index-optimize/)\n\nB+树索引的管理\n---\n创建索引（联合索引）\n\n>ALTER TABLE table_name ADD INDEX index_name (column_list1,column_list2);\n\n>ALTER TABLE table_name ADD UNIQUE (column_list1,column_list2);\n\n>ALTER TABLE table_name ADD PRIMARY KEY (column_list1,column_list2);\n\n>CREATE INDEX index_name ON table_name (column_list1,column_list2);\n\n>CREATE UNIQUE INDEX index_name ON table_name (column_list1,column_list2);\n\n删除索引\n\n>DROP INDEX index_name ON talbe_name;\n\n>ALTER TABLE table_name DROP INDEX index_name;\n\n>ALTER TABLE table_name DROP PRIMARY KEY;\n\n查看索引\n\n>SHOW INDEX FROM talbe_name;\n\n>SHOW KEYS FROM talbe_name;\n\n- Table： 表的名称\n- Non_unique： 非唯一，如果索引不能包括重复词，则为0。如果可以，则为1\n- Key_name： 索引名称，可以用这个名称DROP INDEX\n- Seq_in_index： 索引中该列的位置（常见于联合索引）\n- Column_name： 索引列的名称\n- Collation： 索引存储方式。A：B+树索引，有序。NULL：Hash索引\n- Cardinality： 索引中唯一值的数目的估计值\n- Sub_part： 是否为列的部分被索引，若显示100，则表示只对该列的前100个字符索引。如果显示NULL，则整个列被索引\n- Packed： 关键字如何被压缩\n- Null： 是否为null\n- Index_type： 索引的类型\n- Comment： 注释\n\nB+树索引的查询性能优化\n---\n（1） 使用 Explain 进行分析\n\n[MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)\n\n（2）\n\nSELECT * FROM talbe_name USE INDEX(index_name) WHERE();\n\nUSE INDEX(index_name) 建议优化器使用索引\n\nFORCE INDEX(index_name) 强制优化器使用索引\n\n（3）索引失效的解决方法以及索引使用的注意点\n\n1. 一般在where和join中出现的列需要建立索引\n2. MySQL只对<、<=、=、>、>=、BETWEEN、IN和部分情况下的LIKE才会使用索引\n3. 查询条件包含OR，且有不含索引的列时，索引失效\n4. 联合索引，不符合最左前缀原则，索引失效\n5. LIKE模糊查询以%开头，索引失效\n6. 列类型是字符串，WHERE时不用引号，索引失效\n7. 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效\n\n全文检索\n---\n全文索引(Full-Text Search)是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。\n\n（1）倒排索引（辅助表）\n\n- inverted file index {单词,单词所在文档的ID}\n- full inverted index {单词,(单词所在的文档ID,在具体文档中的位置)}\n\n参考资料：\n---\n- 《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著\n- [从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)\n- [从MySQL Bug#67718浅谈B+树索引的分裂优化](http://allan.li/mysql-index-optimize/)","slug":"InnoDB索引详解","published":1,"updated":"2018-12-20T06:42:33.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmv0006dcxvklzvk54b","content":"<blockquote>\n<p>B树(Balance Tree)本质属于一颗平衡树。</p>\n</blockquote>\n<blockquote>\n<p>B+树是基于B树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n</blockquote>\n<h2 id=\"为什么使用B-树？\"><a href=\"#为什么使用B-树？\" class=\"headerlink\" title=\"为什么使用B+树？\"></a>为什么使用B+树？</h2><p>（1）B+树比起二叉树的优势</p>\n<p>索引以索引文件的形式存储的磁盘上，每次读取节点就会进行一次磁盘IO操作，获取一个页（操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据），而B+树“矮胖”的特点可以减少IO操作次数，以提升效率。</p>\n<p>（2）B+树为什么比B树更合适？</p>\n<ol>\n<li>B+树非叶子节点只包含关键字，每个磁盘块可以存储更多的关键字；而B树非叶子节点还包含数据，所以B+树中每个磁盘块可以存储更多关键字，更矮胖，IO次数更少。</li>\n<li>B+树叶子节点存储全部数据，数据以指针相连形成链表；而B树非叶子节点的数据未存储在叶子节点上。所以B+树的范围查找效率比B树更高。</li>\n<li>B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，所以B+树查找更稳定（并不慢）。</li>\n</ol>\n<h2 id=\"B-树索引的分裂\"><a href=\"#B-树索引的分裂\" class=\"headerlink\" title=\"B+树索引的分裂\"></a>B+树索引的分裂</h2><ol>\n<li>按照原页中点分裂，再将数据插入。（随机插入）</li>\n<li>分裂操作优化：不移动原页，将数据插入到新页中。（递增递减插入）</li>\n</ol>\n<p><a href=\"http://allan.li/mysql-index-optimize/\" target=\"_blank\" rel=\"noopener\">从MySQL Bug#67718浅谈B+树索引的分裂优化</a></p>\n<h2 id=\"B-树索引的管理\"><a href=\"#B-树索引的管理\" class=\"headerlink\" title=\"B+树索引的管理\"></a>B+树索引的管理</h2><p>创建索引（联合索引）</p>\n<blockquote>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name ADD UNIQUE (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name ADD PRIMARY KEY (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>CREATE INDEX index_name ON table_name (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>CREATE UNIQUE INDEX index_name ON table_name (column_list1,column_list2);</p>\n</blockquote>\n<p>删除索引</p>\n<blockquote>\n<p>DROP INDEX index_name ON talbe_name;</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name DROP INDEX index_name;</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name DROP PRIMARY KEY;</p>\n</blockquote>\n<p>查看索引</p>\n<blockquote>\n<p>SHOW INDEX FROM talbe_name;</p>\n</blockquote>\n<blockquote>\n<p>SHOW KEYS FROM talbe_name;</p>\n</blockquote>\n<ul>\n<li>Table： 表的名称</li>\n<li>Non_unique： 非唯一，如果索引不能包括重复词，则为0。如果可以，则为1</li>\n<li>Key_name： 索引名称，可以用这个名称DROP INDEX</li>\n<li>Seq_in_index： 索引中该列的位置（常见于联合索引）</li>\n<li>Column_name： 索引列的名称</li>\n<li>Collation： 索引存储方式。A：B+树索引，有序。NULL：Hash索引</li>\n<li>Cardinality： 索引中唯一值的数目的估计值</li>\n<li>Sub_part： 是否为列的部分被索引，若显示100，则表示只对该列的前100个字符索引。如果显示NULL，则整个列被索引</li>\n<li>Packed： 关键字如何被压缩</li>\n<li>Null： 是否为null</li>\n<li>Index_type： 索引的类型</li>\n<li>Comment： 注释</li>\n</ul>\n<h2 id=\"B-树索引的查询性能优化\"><a href=\"#B-树索引的查询性能优化\" class=\"headerlink\" title=\"B+树索引的查询性能优化\"></a>B+树索引的查询性能优化</h2><p>（1） 使用 Explain 进行分析</p>\n<p><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">MySQL 性能优化神器 Explain 使用分析</a></p>\n<p>（2）</p>\n<p>SELECT * FROM talbe_name USE INDEX(index_name) WHERE();</p>\n<p>USE INDEX(index_name) 建议优化器使用索引</p>\n<p>FORCE INDEX(index_name) 强制优化器使用索引</p>\n<p>（3）索引失效的解决方法以及索引使用的注意点</p>\n<ol>\n<li>一般在where和join中出现的列需要建立索引</li>\n<li>MySQL只对&lt;、&lt;=、=、&gt;、&gt;=、BETWEEN、IN和部分情况下的LIKE才会使用索引</li>\n<li>查询条件包含OR，且有不含索引的列时，索引失效</li>\n<li>联合索引，不符合最左前缀原则，索引失效</li>\n<li>LIKE模糊查询以%开头，索引失效</li>\n<li>列类型是字符串，WHERE时不用引号，索引失效</li>\n<li>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</li>\n</ol>\n<h2 id=\"全文检索\"><a href=\"#全文检索\" class=\"headerlink\" title=\"全文检索\"></a>全文检索</h2><p>全文索引(Full-Text Search)是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。</p>\n<p>（1）倒排索引（辅助表）</p>\n<ul>\n<li>inverted file index {单词,单词所在文档的ID}</li>\n<li>full inverted index {单词,(单词所在的文档ID,在具体文档中的位置)}</li>\n</ul>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著</li>\n<li><a href=\"https://blog.csdn.net/v_JULY_v/article/details/6530142\" target=\"_blank\" rel=\"noopener\">从B树、B+树、B*树谈到R 树</a></li>\n<li><a href=\"http://allan.li/mysql-index-optimize/\" target=\"_blank\" rel=\"noopener\">从MySQL Bug#67718浅谈B+树索引的分裂优化</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>B树(Balance Tree)本质属于一颗平衡树。</p>\n</blockquote>\n<blockquote>\n<p>B+树是基于B树和叶子节点顺序访问指针进行实现，它具有B树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>\n</blockquote>\n<h2 id=\"为什么使用B-树？\"><a href=\"#为什么使用B-树？\" class=\"headerlink\" title=\"为什么使用B+树？\"></a>为什么使用B+树？</h2><p>（1）B+树比起二叉树的优势</p>\n<p>索引以索引文件的形式存储的磁盘上，每次读取节点就会进行一次磁盘IO操作，获取一个页（操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据），而B+树“矮胖”的特点可以减少IO操作次数，以提升效率。</p>\n<p>（2）B+树为什么比B树更合适？</p>\n<ol>\n<li>B+树非叶子节点只包含关键字，每个磁盘块可以存储更多的关键字；而B树非叶子节点还包含数据，所以B+树中每个磁盘块可以存储更多关键字，更矮胖，IO次数更少。</li>\n<li>B+树叶子节点存储全部数据，数据以指针相连形成链表；而B树非叶子节点的数据未存储在叶子节点上。所以B+树的范围查找效率比B树更高。</li>\n<li>B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，所以B+树查找更稳定（并不慢）。</li>\n</ol>\n<h2 id=\"B-树索引的分裂\"><a href=\"#B-树索引的分裂\" class=\"headerlink\" title=\"B+树索引的分裂\"></a>B+树索引的分裂</h2><ol>\n<li>按照原页中点分裂，再将数据插入。（随机插入）</li>\n<li>分裂操作优化：不移动原页，将数据插入到新页中。（递增递减插入）</li>\n</ol>\n<p><a href=\"http://allan.li/mysql-index-optimize/\" target=\"_blank\" rel=\"noopener\">从MySQL Bug#67718浅谈B+树索引的分裂优化</a></p>\n<h2 id=\"B-树索引的管理\"><a href=\"#B-树索引的管理\" class=\"headerlink\" title=\"B+树索引的管理\"></a>B+树索引的管理</h2><p>创建索引（联合索引）</p>\n<blockquote>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name ADD UNIQUE (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name ADD PRIMARY KEY (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>CREATE INDEX index_name ON table_name (column_list1,column_list2);</p>\n</blockquote>\n<blockquote>\n<p>CREATE UNIQUE INDEX index_name ON table_name (column_list1,column_list2);</p>\n</blockquote>\n<p>删除索引</p>\n<blockquote>\n<p>DROP INDEX index_name ON talbe_name;</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name DROP INDEX index_name;</p>\n</blockquote>\n<blockquote>\n<p>ALTER TABLE table_name DROP PRIMARY KEY;</p>\n</blockquote>\n<p>查看索引</p>\n<blockquote>\n<p>SHOW INDEX FROM talbe_name;</p>\n</blockquote>\n<blockquote>\n<p>SHOW KEYS FROM talbe_name;</p>\n</blockquote>\n<ul>\n<li>Table： 表的名称</li>\n<li>Non_unique： 非唯一，如果索引不能包括重复词，则为0。如果可以，则为1</li>\n<li>Key_name： 索引名称，可以用这个名称DROP INDEX</li>\n<li>Seq_in_index： 索引中该列的位置（常见于联合索引）</li>\n<li>Column_name： 索引列的名称</li>\n<li>Collation： 索引存储方式。A：B+树索引，有序。NULL：Hash索引</li>\n<li>Cardinality： 索引中唯一值的数目的估计值</li>\n<li>Sub_part： 是否为列的部分被索引，若显示100，则表示只对该列的前100个字符索引。如果显示NULL，则整个列被索引</li>\n<li>Packed： 关键字如何被压缩</li>\n<li>Null： 是否为null</li>\n<li>Index_type： 索引的类型</li>\n<li>Comment： 注释</li>\n</ul>\n<h2 id=\"B-树索引的查询性能优化\"><a href=\"#B-树索引的查询性能优化\" class=\"headerlink\" title=\"B+树索引的查询性能优化\"></a>B+树索引的查询性能优化</h2><p>（1） 使用 Explain 进行分析</p>\n<p><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">MySQL 性能优化神器 Explain 使用分析</a></p>\n<p>（2）</p>\n<p>SELECT * FROM talbe_name USE INDEX(index_name) WHERE();</p>\n<p>USE INDEX(index_name) 建议优化器使用索引</p>\n<p>FORCE INDEX(index_name) 强制优化器使用索引</p>\n<p>（3）索引失效的解决方法以及索引使用的注意点</p>\n<ol>\n<li>一般在where和join中出现的列需要建立索引</li>\n<li>MySQL只对&lt;、&lt;=、=、&gt;、&gt;=、BETWEEN、IN和部分情况下的LIKE才会使用索引</li>\n<li>查询条件包含OR，且有不含索引的列时，索引失效</li>\n<li>联合索引，不符合最左前缀原则，索引失效</li>\n<li>LIKE模糊查询以%开头，索引失效</li>\n<li>列类型是字符串，WHERE时不用引号，索引失效</li>\n<li>当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效</li>\n</ol>\n<h2 id=\"全文检索\"><a href=\"#全文检索\" class=\"headerlink\" title=\"全文检索\"></a>全文检索</h2><p>全文索引(Full-Text Search)是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。</p>\n<p>（1）倒排索引（辅助表）</p>\n<ul>\n<li>inverted file index {单词,单词所在文档的ID}</li>\n<li>full inverted index {单词,(单词所在的文档ID,在具体文档中的位置)}</li>\n</ul>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《MySQL技术内幕:InnoDB存储引擎(第2版)》 姜承尧 著</li>\n<li><a href=\"https://blog.csdn.net/v_JULY_v/article/details/6530142\" target=\"_blank\" rel=\"noopener\">从B树、B+树、B*树谈到R 树</a></li>\n<li><a href=\"http://allan.li/mysql-index-optimize/\" target=\"_blank\" rel=\"noopener\">从MySQL Bug#67718浅谈B+树索引的分裂优化</a></li>\n</ul>\n"},{"title":"深入理解CAS","date":"2018-12-20T06:38:44.000Z","_content":"\n一、锁机制\n---\n1. 悲观锁(互斥同步)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。例如：synchronized和ReentrantLock。\n2. 乐观锁(非阻塞同步)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。\n\n二、CAS概念\n---\nCAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值。\n\n三、Atomic类实现原理\n---\n以AtomicInteger的incrementAndGet和compareAndSet方法为例\n\n``` java\npublic final int incrementAndGet() {//当前值加1,并返回新值\n    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n\n1. AtomicInteger里面的value被加载在工作内存中，通过getIntVolatile(var1, var2)方法获取value的值。\n\n2. 通过compareAndSwapInt方法，以原子操作修改值。\n\n3. 若不成功则循环获取value值，直到compareAndSwapInt方法修改值成功并返回true。\n\n``` java\npublic final boolean compareAndSet(int expect, int update) {//如果当前值为expect,则设置为update\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n该函数若更新值失败，则直接返回false。无循环是因为要依赖expect值，更新失败说明不符合expect值，故不做无用功。\n\n四、CAS与synchronized性能比较\n---\n\n``` java\npublic class Main {\n    private static volatile int a=0;\n    private static AtomicInteger atomicInteger = new AtomicInteger(0);\n    private static int m=10000000;//循环次数\n\n    public static void main(String[] args) throws InterruptedException {\n        int amount=2;//线程数量\n        Thread[] threads=new Thread[amount];\n        //Syn\n        long start0=System.currentTimeMillis();\n        for (int i=0; i<amount; i++){\n            threads[i]=new Thread(new MyThread0());\n            threads[i].start();\n        }\n        for (int i=0; i<amount; i++) threads[i].join();\n        long end0=System.currentTimeMillis();\n        System.out.println(\"There is \" + amount + \" threads to run \" + m + \" , Syn use \"+(end0-start0)+ \" ms\");\n\n        //CAS\n        long start1=System.currentTimeMillis();\n        for (int i=0; i<amount; i++){\n            threads[i]=new Thread(new MyThread1());\n            threads[i].start();\n        }\n        for (int i=0; i<amount; i++) threads[i].join();\n        long end1=System.currentTimeMillis();\n        System.out.println(\"There is \" + amount + \" threads to run \" + m + \" , CAS use \"+(end1-start1)+ \" ms\");\n\n    }\n    static class MyThread0 implements Runnable{\n        @Override\n        public void run() {\n            synchronized(Main.class){\n                for (int i=0; i<m; i++)\n                    a++;\n            }\n        }\n    }\n    static class MyThread1 implements Runnable{\n        @Override\n        public void run() {\n            for (int i=0; i<m; i++)\n                atomicInteger.incrementAndGet();\n        }\n    }\n}\n```\nThere is 8 threads to run 1000 , Syn use 8.7 ms\n\nThere is 8 threads to run 1000 , CAS use 4.7 ms\n***\n\nThere is 8 threads to run 10000 , Syn use 14.4 ms\n\nThere is 8 threads to run 10000 , CAS use 11.5 ms\n***\n\nThere is 16 threads to run 10000 , Syn use 26.2 ms\n\nThere is 16 threads to run 10000 , CAS use 19.6 ms\n***\n\nThere is 32 threads to run 10000 , Syn use 25.9 ms\n\nThere is 32 threads to run 10000 , CAS use 31.9 ms\n\n以上数据由每10次结果计算一次平均值得出。从测试结果看，在锁竞争不激烈的情况下CAS乐观锁效率更高；锁竞争激烈的情况下synchronized悲观锁效率更高。\n\n原因：锁竞争低的情况下，**synchronized仍进行线程阻塞和唤醒切换以及用户态内核态间切换操作浪费大量CPU资源，而CAS基于硬件实现，且自旋较少，不需要进入内核或切换线程**，效率远高于synchronized。一旦锁竞争激烈，CAS操作会耗费大量CPU资源在自旋，故效率低于synchronized。\n\n五、CAS为什么是原子操作\n---\n\n来自[gdkkx](http://angovia.me/)的提示：换一个思路来思考这个问题，如果需要实现一个有原子性的CAS操作，如何实现？\n\n(1) 总线加锁\n\n所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。(个人看法：如果使用总线加锁，开销很大，所以，并不是期望的结果)\n\n(2) 缓存锁定\n\n在同一时刻我们只需保证对某个内存地址的操作是原子性，利用缓存一致性机制来保证操作的原子性。\n\n> 具体实现原理参考博客：[聊聊并发（五）——原子操作的实现原理](https://www.infoq.cn/article/atomic-operation)\n\n六、CAS的ABA问题\n---\n在CAS算法中，如果V的值首先由A变成B，再由B变成A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。\n\n解决方法：\n\n1. 垃圾回收机制支持\n2. 给对象加版本号，使用：AtomicStampedReference(“对象-引用”二元组，通过在引用上加上”版本号”)或者AtomicMarkableReference(“对象-布尔值”二元组，布尔值标记是否为“已删除节点”)\n\n七、总结\n---\n1. 实践过程中，运行时间并不稳定，所以临界值并不准确。原因：可能是计算机其他进程影响。\n2. 代码中循环次数m越高，CAS效率越低。原因：循环次数的增加，间接增加了CAS中锁竞争，而对synchronized影响不大，若将for写在synchronized之外则效率会大大降低。\n3. 乐观锁也并非完美的锁机制。没有所有情况都完美的解，只有某些情况下的最优解。\n\n参考资料：\n---\n\n- 《实战Java高并发程序设计》 葛一鸣/郭超 著\n- Java并发编程实战([Java Concurrency in Practice](https://inbravo.github.io/docs/refer/java-concurrency.pdf))\n- [聊聊并发（五）——原子操作的实现原理](https://www.infoq.cn/article/atomic-operation)\n","source":"_posts/深入理解CAS.md","raw":"---\ntitle: 深入理解CAS\ndate: 2018-12-20 14:38:44\ncategories: \n\t- Java多线程\n---\n\n一、锁机制\n---\n1. 悲观锁(互斥同步)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。例如：synchronized和ReentrantLock。\n2. 乐观锁(非阻塞同步)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。\n\n二、CAS概念\n---\nCAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值。\n\n三、Atomic类实现原理\n---\n以AtomicInteger的incrementAndGet和compareAndSet方法为例\n\n``` java\npublic final int incrementAndGet() {//当前值加1,并返回新值\n    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n}\n\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n\n1. AtomicInteger里面的value被加载在工作内存中，通过getIntVolatile(var1, var2)方法获取value的值。\n\n2. 通过compareAndSwapInt方法，以原子操作修改值。\n\n3. 若不成功则循环获取value值，直到compareAndSwapInt方法修改值成功并返回true。\n\n``` java\npublic final boolean compareAndSet(int expect, int update) {//如果当前值为expect,则设置为update\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n}\n```\n该函数若更新值失败，则直接返回false。无循环是因为要依赖expect值，更新失败说明不符合expect值，故不做无用功。\n\n四、CAS与synchronized性能比较\n---\n\n``` java\npublic class Main {\n    private static volatile int a=0;\n    private static AtomicInteger atomicInteger = new AtomicInteger(0);\n    private static int m=10000000;//循环次数\n\n    public static void main(String[] args) throws InterruptedException {\n        int amount=2;//线程数量\n        Thread[] threads=new Thread[amount];\n        //Syn\n        long start0=System.currentTimeMillis();\n        for (int i=0; i<amount; i++){\n            threads[i]=new Thread(new MyThread0());\n            threads[i].start();\n        }\n        for (int i=0; i<amount; i++) threads[i].join();\n        long end0=System.currentTimeMillis();\n        System.out.println(\"There is \" + amount + \" threads to run \" + m + \" , Syn use \"+(end0-start0)+ \" ms\");\n\n        //CAS\n        long start1=System.currentTimeMillis();\n        for (int i=0; i<amount; i++){\n            threads[i]=new Thread(new MyThread1());\n            threads[i].start();\n        }\n        for (int i=0; i<amount; i++) threads[i].join();\n        long end1=System.currentTimeMillis();\n        System.out.println(\"There is \" + amount + \" threads to run \" + m + \" , CAS use \"+(end1-start1)+ \" ms\");\n\n    }\n    static class MyThread0 implements Runnable{\n        @Override\n        public void run() {\n            synchronized(Main.class){\n                for (int i=0; i<m; i++)\n                    a++;\n            }\n        }\n    }\n    static class MyThread1 implements Runnable{\n        @Override\n        public void run() {\n            for (int i=0; i<m; i++)\n                atomicInteger.incrementAndGet();\n        }\n    }\n}\n```\nThere is 8 threads to run 1000 , Syn use 8.7 ms\n\nThere is 8 threads to run 1000 , CAS use 4.7 ms\n***\n\nThere is 8 threads to run 10000 , Syn use 14.4 ms\n\nThere is 8 threads to run 10000 , CAS use 11.5 ms\n***\n\nThere is 16 threads to run 10000 , Syn use 26.2 ms\n\nThere is 16 threads to run 10000 , CAS use 19.6 ms\n***\n\nThere is 32 threads to run 10000 , Syn use 25.9 ms\n\nThere is 32 threads to run 10000 , CAS use 31.9 ms\n\n以上数据由每10次结果计算一次平均值得出。从测试结果看，在锁竞争不激烈的情况下CAS乐观锁效率更高；锁竞争激烈的情况下synchronized悲观锁效率更高。\n\n原因：锁竞争低的情况下，**synchronized仍进行线程阻塞和唤醒切换以及用户态内核态间切换操作浪费大量CPU资源，而CAS基于硬件实现，且自旋较少，不需要进入内核或切换线程**，效率远高于synchronized。一旦锁竞争激烈，CAS操作会耗费大量CPU资源在自旋，故效率低于synchronized。\n\n五、CAS为什么是原子操作\n---\n\n来自[gdkkx](http://angovia.me/)的提示：换一个思路来思考这个问题，如果需要实现一个有原子性的CAS操作，如何实现？\n\n(1) 总线加锁\n\n所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。(个人看法：如果使用总线加锁，开销很大，所以，并不是期望的结果)\n\n(2) 缓存锁定\n\n在同一时刻我们只需保证对某个内存地址的操作是原子性，利用缓存一致性机制来保证操作的原子性。\n\n> 具体实现原理参考博客：[聊聊并发（五）——原子操作的实现原理](https://www.infoq.cn/article/atomic-operation)\n\n六、CAS的ABA问题\n---\n在CAS算法中，如果V的值首先由A变成B，再由B变成A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。\n\n解决方法：\n\n1. 垃圾回收机制支持\n2. 给对象加版本号，使用：AtomicStampedReference(“对象-引用”二元组，通过在引用上加上”版本号”)或者AtomicMarkableReference(“对象-布尔值”二元组，布尔值标记是否为“已删除节点”)\n\n七、总结\n---\n1. 实践过程中，运行时间并不稳定，所以临界值并不准确。原因：可能是计算机其他进程影响。\n2. 代码中循环次数m越高，CAS效率越低。原因：循环次数的增加，间接增加了CAS中锁竞争，而对synchronized影响不大，若将for写在synchronized之外则效率会大大降低。\n3. 乐观锁也并非完美的锁机制。没有所有情况都完美的解，只有某些情况下的最优解。\n\n参考资料：\n---\n\n- 《实战Java高并发程序设计》 葛一鸣/郭超 著\n- Java并发编程实战([Java Concurrency in Practice](https://inbravo.github.io/docs/refer/java-concurrency.pdf))\n- [聊聊并发（五）——原子操作的实现原理](https://www.infoq.cn/article/atomic-operation)\n","slug":"深入理解CAS","published":1,"updated":"2018-12-20T07:01:15.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmw0007dcxvn1dwfjte","content":"<h2 id=\"一、锁机制\"><a href=\"#一、锁机制\" class=\"headerlink\" title=\"一、锁机制\"></a>一、锁机制</h2><ol>\n<li>悲观锁(互斥同步)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。例如：synchronized和ReentrantLock。</li>\n<li>乐观锁(非阻塞同步)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。</li>\n</ol>\n<h2 id=\"二、CAS概念\"><a href=\"#二、CAS概念\" class=\"headerlink\" title=\"二、CAS概念\"></a>二、CAS概念</h2><p>CAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值。</p>\n<h2 id=\"三、Atomic类实现原理\"><a href=\"#三、Atomic类实现原理\" class=\"headerlink\" title=\"三、Atomic类实现原理\"></a>三、Atomic类实现原理</h2><p>以AtomicInteger的incrementAndGet和compareAndSet方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//当前值加1,并返回新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>AtomicInteger里面的value被加载在工作内存中，通过getIntVolatile(var1, var2)方法获取value的值。</p>\n</li>\n<li><p>通过compareAndSwapInt方法，以原子操作修改值。</p>\n</li>\n<li><p>若不成功则循环获取value值，直到compareAndSwapInt方法修改值成功并返回true。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;<span class=\"comment\">//如果当前值为expect,则设置为update</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数若更新值失败，则直接返回false。无循环是因为要依赖expect值，更新失败说明不符合expect值，故不做无用功。</p>\n<h2 id=\"四、CAS与synchronized性能比较\"><a href=\"#四、CAS与synchronized性能比较\" class=\"headerlink\" title=\"四、CAS与synchronized性能比较\"></a>四、CAS与synchronized性能比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger atomicInteger = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m=<span class=\"number\">10000000</span>;<span class=\"comment\">//循环次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> amount=<span class=\"number\">2</span>;<span class=\"comment\">//线程数量</span></span><br><span class=\"line\">        Thread[] threads=<span class=\"keyword\">new</span> Thread[amount];</span><br><span class=\"line\">        <span class=\"comment\">//Syn</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start0=System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++)&#123;</span><br><span class=\"line\">            threads[i]=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyThread0());</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++) threads[i].join();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end0=System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"There is \"</span> + amount + <span class=\"string\">\" threads to run \"</span> + m + <span class=\"string\">\" , Syn use \"</span>+(end0-start0)+ <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//CAS</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start1=System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++)&#123;</span><br><span class=\"line\">            threads[i]=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyThread1());</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++) threads[i].join();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end1=System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"There is \"</span> + amount + <span class=\"string\">\" threads to run \"</span> + m + <span class=\"string\">\" , CAS use \"</span>+(end1-start1)+ <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread0</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Main.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;m; i++)</span><br><span class=\"line\">                    a++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;m; i++)</span><br><span class=\"line\">                atomicInteger.incrementAndGet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There is 8 threads to run 1000 , Syn use 8.7 ms</p>\n<p>There is 8 threads to run 1000 , CAS use 4.7 ms</p>\n<hr>\n<p>There is 8 threads to run 10000 , Syn use 14.4 ms</p>\n<p>There is 8 threads to run 10000 , CAS use 11.5 ms</p>\n<hr>\n<p>There is 16 threads to run 10000 , Syn use 26.2 ms</p>\n<p>There is 16 threads to run 10000 , CAS use 19.6 ms</p>\n<hr>\n<p>There is 32 threads to run 10000 , Syn use 25.9 ms</p>\n<p>There is 32 threads to run 10000 , CAS use 31.9 ms</p>\n<p>以上数据由每10次结果计算一次平均值得出。从测试结果看，在锁竞争不激烈的情况下CAS乐观锁效率更高；锁竞争激烈的情况下synchronized悲观锁效率更高。</p>\n<p>原因：锁竞争低的情况下，<strong>synchronized仍进行线程阻塞和唤醒切换以及用户态内核态间切换操作浪费大量CPU资源，而CAS基于硬件实现，且自旋较少，不需要进入内核或切换线程</strong>，效率远高于synchronized。一旦锁竞争激烈，CAS操作会耗费大量CPU资源在自旋，故效率低于synchronized。</p>\n<h2 id=\"五、CAS为什么是原子操作\"><a href=\"#五、CAS为什么是原子操作\" class=\"headerlink\" title=\"五、CAS为什么是原子操作\"></a>五、CAS为什么是原子操作</h2><p>来自<a href=\"http://angovia.me/\" target=\"_blank\" rel=\"noopener\">gdkkx</a>的提示：换一个思路来思考这个问题，如果需要实现一个有原子性的CAS操作，如何实现？</p>\n<p>(1) 总线加锁</p>\n<p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。(个人看法：如果使用总线加锁，开销很大，所以，并不是期望的结果)</p>\n<p>(2) 缓存锁定</p>\n<p>在同一时刻我们只需保证对某个内存地址的操作是原子性，利用缓存一致性机制来保证操作的原子性。</p>\n<blockquote>\n<p>具体实现原理参考博客：<a href=\"https://www.infoq.cn/article/atomic-operation\" target=\"_blank\" rel=\"noopener\">聊聊并发（五）——原子操作的实现原理</a></p>\n</blockquote>\n<h2 id=\"六、CAS的ABA问题\"><a href=\"#六、CAS的ABA问题\" class=\"headerlink\" title=\"六、CAS的ABA问题\"></a>六、CAS的ABA问题</h2><p>在CAS算法中，如果V的值首先由A变成B，再由B变成A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。</p>\n<p>解决方法：</p>\n<ol>\n<li>垃圾回收机制支持</li>\n<li>给对象加版本号，使用：AtomicStampedReference(“对象-引用”二元组，通过在引用上加上”版本号”)或者AtomicMarkableReference(“对象-布尔值”二元组，布尔值标记是否为“已删除节点”)</li>\n</ol>\n<h2 id=\"七、总结\"><a href=\"#七、总结\" class=\"headerlink\" title=\"七、总结\"></a>七、总结</h2><ol>\n<li>实践过程中，运行时间并不稳定，所以临界值并不准确。原因：可能是计算机其他进程影响。</li>\n<li>代码中循环次数m越高，CAS效率越低。原因：循环次数的增加，间接增加了CAS中锁竞争，而对synchronized影响不大，若将for写在synchronized之外则效率会大大降低。</li>\n<li>乐观锁也并非完美的锁机制。没有所有情况都完美的解，只有某些情况下的最优解。</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《实战Java高并发程序设计》 葛一鸣/郭超 著</li>\n<li>Java并发编程实战(<a href=\"https://inbravo.github.io/docs/refer/java-concurrency.pdf\" target=\"_blank\" rel=\"noopener\">Java Concurrency in Practice</a>)</li>\n<li><a href=\"https://www.infoq.cn/article/atomic-operation\" target=\"_blank\" rel=\"noopener\">聊聊并发（五）——原子操作的实现原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、锁机制\"><a href=\"#一、锁机制\" class=\"headerlink\" title=\"一、锁机制\"></a>一、锁机制</h2><ol>\n<li>悲观锁(互斥同步)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。例如：synchronized和ReentrantLock。</li>\n<li>乐观锁(非阻塞同步)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。</li>\n</ol>\n<h2 id=\"二、CAS概念\"><a href=\"#二、CAS概念\" class=\"headerlink\" title=\"二、CAS概念\"></a>二、CAS概念</h2><p>CAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值。</p>\n<h2 id=\"三、Atomic类实现原理\"><a href=\"#三、Atomic类实现原理\" class=\"headerlink\" title=\"三、Atomic类实现原理\"></a>三、Atomic类实现原理</h2><p>以AtomicInteger的incrementAndGet和compareAndSet方法为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//当前值加1,并返回新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>AtomicInteger里面的value被加载在工作内存中，通过getIntVolatile(var1, var2)方法获取value的值。</p>\n</li>\n<li><p>通过compareAndSwapInt方法，以原子操作修改值。</p>\n</li>\n<li><p>若不成功则循环获取value值，直到compareAndSwapInt方法修改值成功并返回true。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;<span class=\"comment\">//如果当前值为expect,则设置为update</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数若更新值失败，则直接返回false。无循环是因为要依赖expect值，更新失败说明不符合expect值，故不做无用功。</p>\n<h2 id=\"四、CAS与synchronized性能比较\"><a href=\"#四、CAS与synchronized性能比较\" class=\"headerlink\" title=\"四、CAS与synchronized性能比较\"></a>四、CAS与synchronized性能比较</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger atomicInteger = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> m=<span class=\"number\">10000000</span>;<span class=\"comment\">//循环次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> amount=<span class=\"number\">2</span>;<span class=\"comment\">//线程数量</span></span><br><span class=\"line\">        Thread[] threads=<span class=\"keyword\">new</span> Thread[amount];</span><br><span class=\"line\">        <span class=\"comment\">//Syn</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start0=System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++)&#123;</span><br><span class=\"line\">            threads[i]=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyThread0());</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++) threads[i].join();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end0=System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"There is \"</span> + amount + <span class=\"string\">\" threads to run \"</span> + m + <span class=\"string\">\" , Syn use \"</span>+(end0-start0)+ <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//CAS</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start1=System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++)&#123;</span><br><span class=\"line\">            threads[i]=<span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyThread1());</span><br><span class=\"line\">            threads[i].start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;amount; i++) threads[i].join();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end1=System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"There is \"</span> + amount + <span class=\"string\">\" threads to run \"</span> + m + <span class=\"string\">\" , CAS use \"</span>+(end1-start1)+ <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread0</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Main.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;m; i++)</span><br><span class=\"line\">                    a++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;m; i++)</span><br><span class=\"line\">                atomicInteger.incrementAndGet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There is 8 threads to run 1000 , Syn use 8.7 ms</p>\n<p>There is 8 threads to run 1000 , CAS use 4.7 ms</p>\n<hr>\n<p>There is 8 threads to run 10000 , Syn use 14.4 ms</p>\n<p>There is 8 threads to run 10000 , CAS use 11.5 ms</p>\n<hr>\n<p>There is 16 threads to run 10000 , Syn use 26.2 ms</p>\n<p>There is 16 threads to run 10000 , CAS use 19.6 ms</p>\n<hr>\n<p>There is 32 threads to run 10000 , Syn use 25.9 ms</p>\n<p>There is 32 threads to run 10000 , CAS use 31.9 ms</p>\n<p>以上数据由每10次结果计算一次平均值得出。从测试结果看，在锁竞争不激烈的情况下CAS乐观锁效率更高；锁竞争激烈的情况下synchronized悲观锁效率更高。</p>\n<p>原因：锁竞争低的情况下，<strong>synchronized仍进行线程阻塞和唤醒切换以及用户态内核态间切换操作浪费大量CPU资源，而CAS基于硬件实现，且自旋较少，不需要进入内核或切换线程</strong>，效率远高于synchronized。一旦锁竞争激烈，CAS操作会耗费大量CPU资源在自旋，故效率低于synchronized。</p>\n<h2 id=\"五、CAS为什么是原子操作\"><a href=\"#五、CAS为什么是原子操作\" class=\"headerlink\" title=\"五、CAS为什么是原子操作\"></a>五、CAS为什么是原子操作</h2><p>来自<a href=\"http://angovia.me/\" target=\"_blank\" rel=\"noopener\">gdkkx</a>的提示：换一个思路来思考这个问题，如果需要实现一个有原子性的CAS操作，如何实现？</p>\n<p>(1) 总线加锁</p>\n<p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住, 那么该处理器可以独占使用共享内存。(个人看法：如果使用总线加锁，开销很大，所以，并不是期望的结果)</p>\n<p>(2) 缓存锁定</p>\n<p>在同一时刻我们只需保证对某个内存地址的操作是原子性，利用缓存一致性机制来保证操作的原子性。</p>\n<blockquote>\n<p>具体实现原理参考博客：<a href=\"https://www.infoq.cn/article/atomic-operation\" target=\"_blank\" rel=\"noopener\">聊聊并发（五）——原子操作的实现原理</a></p>\n</blockquote>\n<h2 id=\"六、CAS的ABA问题\"><a href=\"#六、CAS的ABA问题\" class=\"headerlink\" title=\"六、CAS的ABA问题\"></a>六、CAS的ABA问题</h2><p>在CAS算法中，如果V的值首先由A变成B，再由B变成A，那么仍然被认为是发生了变化，并需要重新执行算法中的某些步骤。</p>\n<p>解决方法：</p>\n<ol>\n<li>垃圾回收机制支持</li>\n<li>给对象加版本号，使用：AtomicStampedReference(“对象-引用”二元组，通过在引用上加上”版本号”)或者AtomicMarkableReference(“对象-布尔值”二元组，布尔值标记是否为“已删除节点”)</li>\n</ol>\n<h2 id=\"七、总结\"><a href=\"#七、总结\" class=\"headerlink\" title=\"七、总结\"></a>七、总结</h2><ol>\n<li>实践过程中，运行时间并不稳定，所以临界值并不准确。原因：可能是计算机其他进程影响。</li>\n<li>代码中循环次数m越高，CAS效率越低。原因：循环次数的增加，间接增加了CAS中锁竞争，而对synchronized影响不大，若将for写在synchronized之外则效率会大大降低。</li>\n<li>乐观锁也并非完美的锁机制。没有所有情况都完美的解，只有某些情况下的最优解。</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《实战Java高并发程序设计》 葛一鸣/郭超 著</li>\n<li>Java并发编程实战(<a href=\"https://inbravo.github.io/docs/refer/java-concurrency.pdf\" target=\"_blank\" rel=\"noopener\">Java Concurrency in Practice</a>)</li>\n<li><a href=\"https://www.infoq.cn/article/atomic-operation\" target=\"_blank\" rel=\"noopener\">聊聊并发（五）——原子操作的实现原理</a></li>\n</ul>\n"},{"title":"方法区的OOM","date":"2018-12-20T06:44:08.000Z","_content":"\n一、JDK1.6 64bit下方法区的OOM\n---\n今天跑了一个项目(JDK1.6，Windows 64bit)，然后抛出了这样一个异常\n\njava.lang.OutOfMemoryError: PermGen space\n\n2018-09-19 09:18:23 JRebel: ERROR Failed to transform class xxx/xxx/xxx\n\n我的解决方法：在IDEA中设置Tomcat VM options 增大这两个参数-XX:PermSize -XX:MaxPermSize（-XX:PermSize设置方法区初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大方法区内存的大小，默认是物理内存的1/4。）\n\n\n二、JDK1.7前后的方法区\n---\n\nPermGen space(Permanent Generation space)翻译为永久代。但个人理解就是JDK1.6以及之前的运行时数据区的‘方法区’。\n\n周志明老师的《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 P56 代码清单2-6如下\n\n``` java\npublic class RuntimeConstantPoolOOM {\n    public static void main(String[] args){\n        //使用List保持常量池引用，避免Full GC回收常量池行为\n        List<String> list = new ArrayList<String>();\n        int i=0;\n        while (true){\n            list.add(String.valueOf(i++).intern());\n        }\n    }\n}\n```\n书中所描述的java.lang.OutOfMemoryError: PermGen space是由String造成的。但这只是JDK1.6的情况。如果用JDK1.7以后的版本编译，就会抛出java.lang.OutOfMemoryError: Java heap space。\n\n原因如下（JDK1.7前后方法区中数据的分配）：\n\n1. JDK1.6及之前 ： 方法区中存储类信息、常量池、静态变量、JIT编译后的代码等数据。（周志明老师的《深入理解Java虚拟机》描述的就是这种情况。）\n\n2. JDK1.7 ： SymbolTable(符号引用)移到Native Memory，StringTable(字符串常量池)移到Java Heap，class statics(类的静态变量)移到了Java Heap\n\n3. JDK1.8 ： 移除永久代。取而代之的是元空间(Metaspace)。大多数类的元数据存储在Metaspace中。\n\n三、为什么移除永久代？\n---\n\n1. 字符串存在永久代中，容易出现性能问题和内存溢出。\n2. 永久代大小不容易确定，PermSize指定太小容易造成永久代OOM\n3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。\n4. 其他虚拟机没有永久代的概念。可能会将HotSpot与JRockit合并。\n\n参考资料：\n---\n\n- 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明著\n- [知乎问题：方法区的Class信息,又称为永久代,是否属于Java堆？](https://www.zhihu.com/question/49044988/answer/113961406)\n- [JVM的Heap Memory和Native Memory](https://blog.csdn.net/u013721793/article/details/51204001)","source":"_posts/方法区的OOM.md","raw":"---\ntitle: 方法区的OOM\ndate: 2018-12-20 14:44:08\ncategories: \n\t- JVM\n---\n\n一、JDK1.6 64bit下方法区的OOM\n---\n今天跑了一个项目(JDK1.6，Windows 64bit)，然后抛出了这样一个异常\n\njava.lang.OutOfMemoryError: PermGen space\n\n2018-09-19 09:18:23 JRebel: ERROR Failed to transform class xxx/xxx/xxx\n\n我的解决方法：在IDEA中设置Tomcat VM options 增大这两个参数-XX:PermSize -XX:MaxPermSize（-XX:PermSize设置方法区初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大方法区内存的大小，默认是物理内存的1/4。）\n\n\n二、JDK1.7前后的方法区\n---\n\nPermGen space(Permanent Generation space)翻译为永久代。但个人理解就是JDK1.6以及之前的运行时数据区的‘方法区’。\n\n周志明老师的《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 P56 代码清单2-6如下\n\n``` java\npublic class RuntimeConstantPoolOOM {\n    public static void main(String[] args){\n        //使用List保持常量池引用，避免Full GC回收常量池行为\n        List<String> list = new ArrayList<String>();\n        int i=0;\n        while (true){\n            list.add(String.valueOf(i++).intern());\n        }\n    }\n}\n```\n书中所描述的java.lang.OutOfMemoryError: PermGen space是由String造成的。但这只是JDK1.6的情况。如果用JDK1.7以后的版本编译，就会抛出java.lang.OutOfMemoryError: Java heap space。\n\n原因如下（JDK1.7前后方法区中数据的分配）：\n\n1. JDK1.6及之前 ： 方法区中存储类信息、常量池、静态变量、JIT编译后的代码等数据。（周志明老师的《深入理解Java虚拟机》描述的就是这种情况。）\n\n2. JDK1.7 ： SymbolTable(符号引用)移到Native Memory，StringTable(字符串常量池)移到Java Heap，class statics(类的静态变量)移到了Java Heap\n\n3. JDK1.8 ： 移除永久代。取而代之的是元空间(Metaspace)。大多数类的元数据存储在Metaspace中。\n\n三、为什么移除永久代？\n---\n\n1. 字符串存在永久代中，容易出现性能问题和内存溢出。\n2. 永久代大小不容易确定，PermSize指定太小容易造成永久代OOM\n3. 永久代会为GC带来不必要的复杂度，并且回收效率偏低。\n4. 其他虚拟机没有永久代的概念。可能会将HotSpot与JRockit合并。\n\n参考资料：\n---\n\n- 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明著\n- [知乎问题：方法区的Class信息,又称为永久代,是否属于Java堆？](https://www.zhihu.com/question/49044988/answer/113961406)\n- [JVM的Heap Memory和Native Memory](https://blog.csdn.net/u013721793/article/details/51204001)","slug":"方法区的OOM","published":1,"updated":"2018-12-20T06:44:52.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdmy0009dcxvpvpj7a55","content":"<h2 id=\"一、JDK1-6-64bit下方法区的OOM\"><a href=\"#一、JDK1-6-64bit下方法区的OOM\" class=\"headerlink\" title=\"一、JDK1.6 64bit下方法区的OOM\"></a>一、JDK1.6 64bit下方法区的OOM</h2><p>今天跑了一个项目(JDK1.6，Windows 64bit)，然后抛出了这样一个异常</p>\n<p>java.lang.OutOfMemoryError: PermGen space</p>\n<p>2018-09-19 09:18:23 JRebel: ERROR Failed to transform class xxx/xxx/xxx</p>\n<p>我的解决方法：在IDEA中设置Tomcat VM options 增大这两个参数-XX:PermSize -XX:MaxPermSize（-XX:PermSize设置方法区初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大方法区内存的大小，默认是物理内存的1/4。）</p>\n<h2 id=\"二、JDK1-7前后的方法区\"><a href=\"#二、JDK1-7前后的方法区\" class=\"headerlink\" title=\"二、JDK1.7前后的方法区\"></a>二、JDK1.7前后的方法区</h2><p>PermGen space(Permanent Generation space)翻译为永久代。但个人理解就是JDK1.6以及之前的运行时数据区的‘方法区’。</p>\n<p>周志明老师的《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 P56 代码清单2-6如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用List保持常量池引用，避免Full GC回收常量池行为</span></span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            list.add(String.valueOf(i++).intern());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中所描述的java.lang.OutOfMemoryError: PermGen space是由String造成的。但这只是JDK1.6的情况。如果用JDK1.7以后的版本编译，就会抛出java.lang.OutOfMemoryError: Java heap space。</p>\n<p>原因如下（JDK1.7前后方法区中数据的分配）：</p>\n<ol>\n<li><p>JDK1.6及之前 ： 方法区中存储类信息、常量池、静态变量、JIT编译后的代码等数据。（周志明老师的《深入理解Java虚拟机》描述的就是这种情况。）</p>\n</li>\n<li><p>JDK1.7 ： SymbolTable(符号引用)移到Native Memory，StringTable(字符串常量池)移到Java Heap，class statics(类的静态变量)移到了Java Heap</p>\n</li>\n<li><p>JDK1.8 ： 移除永久代。取而代之的是元空间(Metaspace)。大多数类的元数据存储在Metaspace中。</p>\n</li>\n</ol>\n<h2 id=\"三、为什么移除永久代？\"><a href=\"#三、为什么移除永久代？\" class=\"headerlink\" title=\"三、为什么移除永久代？\"></a>三、为什么移除永久代？</h2><ol>\n<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>\n<li>永久代大小不容易确定，PermSize指定太小容易造成永久代OOM</li>\n<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>\n<li>其他虚拟机没有永久代的概念。可能会将HotSpot与JRockit合并。</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明著</li>\n<li><a href=\"https://www.zhihu.com/question/49044988/answer/113961406\" target=\"_blank\" rel=\"noopener\">知乎问题：方法区的Class信息,又称为永久代,是否属于Java堆？</a></li>\n<li><a href=\"https://blog.csdn.net/u013721793/article/details/51204001\" target=\"_blank\" rel=\"noopener\">JVM的Heap Memory和Native Memory</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、JDK1-6-64bit下方法区的OOM\"><a href=\"#一、JDK1-6-64bit下方法区的OOM\" class=\"headerlink\" title=\"一、JDK1.6 64bit下方法区的OOM\"></a>一、JDK1.6 64bit下方法区的OOM</h2><p>今天跑了一个项目(JDK1.6，Windows 64bit)，然后抛出了这样一个异常</p>\n<p>java.lang.OutOfMemoryError: PermGen space</p>\n<p>2018-09-19 09:18:23 JRebel: ERROR Failed to transform class xxx/xxx/xxx</p>\n<p>我的解决方法：在IDEA中设置Tomcat VM options 增大这两个参数-XX:PermSize -XX:MaxPermSize（-XX:PermSize设置方法区初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大方法区内存的大小，默认是物理内存的1/4。）</p>\n<h2 id=\"二、JDK1-7前后的方法区\"><a href=\"#二、JDK1-7前后的方法区\" class=\"headerlink\" title=\"二、JDK1.7前后的方法区\"></a>二、JDK1.7前后的方法区</h2><p>PermGen space(Permanent Generation space)翻译为永久代。但个人理解就是JDK1.6以及之前的运行时数据区的‘方法区’。</p>\n<p>周志明老师的《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 P56 代码清单2-6如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用List保持常量池引用，避免Full GC回收常量池行为</span></span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            list.add(String.valueOf(i++).intern());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中所描述的java.lang.OutOfMemoryError: PermGen space是由String造成的。但这只是JDK1.6的情况。如果用JDK1.7以后的版本编译，就会抛出java.lang.OutOfMemoryError: Java heap space。</p>\n<p>原因如下（JDK1.7前后方法区中数据的分配）：</p>\n<ol>\n<li><p>JDK1.6及之前 ： 方法区中存储类信息、常量池、静态变量、JIT编译后的代码等数据。（周志明老师的《深入理解Java虚拟机》描述的就是这种情况。）</p>\n</li>\n<li><p>JDK1.7 ： SymbolTable(符号引用)移到Native Memory，StringTable(字符串常量池)移到Java Heap，class statics(类的静态变量)移到了Java Heap</p>\n</li>\n<li><p>JDK1.8 ： 移除永久代。取而代之的是元空间(Metaspace)。大多数类的元数据存储在Metaspace中。</p>\n</li>\n</ol>\n<h2 id=\"三、为什么移除永久代？\"><a href=\"#三、为什么移除永久代？\" class=\"headerlink\" title=\"三、为什么移除永久代？\"></a>三、为什么移除永久代？</h2><ol>\n<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>\n<li>永久代大小不容易确定，PermSize指定太小容易造成永久代OOM</li>\n<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>\n<li>其他虚拟机没有永久代的概念。可能会将HotSpot与JRockit合并。</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li>《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 周志明著</li>\n<li><a href=\"https://www.zhihu.com/question/49044988/answer/113961406\" target=\"_blank\" rel=\"noopener\">知乎问题：方法区的Class信息,又称为永久代,是否属于Java堆？</a></li>\n<li><a href=\"https://blog.csdn.net/u013721793/article/details/51204001\" target=\"_blank\" rel=\"noopener\">JVM的Heap Memory和Native Memory</a></li>\n</ul>\n"},{"title":"剑指Offer题解","date":"2019-02-18T12:55:23.000Z","_content":"\n## 数组中重复的数字\n\n\n\n> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。\n\n思路：\n\n1. 哈希表,时间复杂度为O(N)，空间复杂度为O(N)\n\n2. 数组中数字都在0到n-1范围内。如果没有重复数字，则每个数字对应其下标。时间复杂度为O(N)，空间复杂度为O(1)\n\n``` java\n    public boolean duplicate(int numbers[],int length,int [] duplication) {\n        if (length<=1 || numbers.length<=1)\n            return false;\n        for (int i=0; i<length; i++){\n            if (numbers[i] != i){\n                if (numbers[numbers[i]]==numbers[i]){\n                    duplication[0]=numbers[i];\n                    return true;\n                }else {\n                    int temp = numbers[numbers[i]];\n                    numbers[numbers[i]] = numbers[i];\n                    numbers[i] = temp;\n                    i--;\n                }\n            }\n        }\n        return false;\n    }\n```\n\n\n\n## 二维数组中的查找\n\n> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n思路：先检查数组左上角，若大于target，则排除最左列，若小于target，则排除最顶行。\n\n\n``` java\n    public boolean Find(int target, int [][] array) {\n        int x = 0;\n        int y = array[0].length-1;\n        while (x <= array.length-1 && y >= 0){\n            if (array[x][y] == target){\n                return true;\n            }else if (array[x][y] > target){\n                y--;\n            }else { // array[x][y] < target\n                x++;\n            }\n        }\n        return false;\n    }\n```\n\n\n\n## 替换空格\n\n> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n思路：先遍历计算空格数量，从后到前移动字符(以保证所有字符只移动一次)。\n\n``` java\n    public String replaceSpace(StringBuffer str) {\n        int length = str.length()-1;\n        for (int i=0; i<=length; i++)\n            if (str.charAt(i) == ' ')\n                str.append(\"  \");\n        for (int i=str.length()-1, j=length; i>=0 && j>=0;){\n            if (str.charAt(j)==' '){\n                str.setCharAt(i--,'0');\n                str.setCharAt(i--,'2');\n                str.setCharAt(i--,'%');\n                j--;\n            }else {\n                str.setCharAt(i,str.charAt(j));\n                i--;\n                j--;\n            }\n        }\n        return str.toString();\n    }\n```\n\n\n\n## 从尾到头打印链表\n\n> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\n\n思路：栈的特点是先进后出\n\n``` java\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        Stack<Integer> stack = new Stack<>();\n        ArrayList<Integer> ret = new ArrayList<>();\n        while (listNode != null){\n            stack.push(listNode.val);\n            listNode=listNode.next;\n        }\n        while (!stack.empty()){\n            ret.add(stack.pop());\n        }\n        return ret;\n    }\n```\n\n\n\n## 重建二叉树\n\n> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n思路：前序遍历的第一个值为根节点的值，这个值将中序遍历结果分成两部分，递归。\n\n具体细节：利用HashMap快速查找中序遍历数组的下标\n\n``` java\n\tMap<Integer, Integer> inMap = new HashMap<>();\n    public TreeNode reConstructBinaryTree(int [] pre, int [] in) {\n        for (int i=0; i< in.length; i++)\n            inMap.put(in[i],i);\n        binaryTree(pre, 0,pre.length-1,0);\n    }\n    public TreeNode binaryTree(int [] pre, int pL, int pR, int inIndex) {\n        if (pL>pR) return null;\n        TreeNode root = new TreeNode(pre[pL]);\n        int rootIndex = inMap.get(pre[pL]);\n        int leftTreeLen = rootIndex-inIndex;\n        root.left=binaryTree(pre,pL+1, pL+leftTreeLen, inIndex);\n        root.right=binaryTree(pre, pL+1+leftTreeLen, pR, rootIndex+1);\n        return root;\n    }\n```\n\n\n\n## 二叉树的下一个节点\n\n> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n\n思路：分两种情况：1.该节点的右节点不为null时，寻找该右节点的最左子节点/该节点的右节点。2.该节点的右节点为null时，寻找第一个左链接指向的节点包含该节点的祖先节点\n\n``` java\n    public TreeLinkNode GetNext(TreeLinkNode pNode){\n        if (pNode.right != null){\n            pNode=pNode.right;\n            while (pNode.left != null){\n                pNode=pNode.left;\n            }\n            return pNode;\n        }else {// pNode.right==null\n            while (pNode.next != null){\n                TreeLinkNode parent = pNode.next;\n                if (parent.left == pNode)\n                    return parent;\n                pNode=parent;\n            }\n        }\n        return null;\n    }\n```\n\n\n\n## 用两个栈实现队列\n\n> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n思路：一个出栈，一个入栈。若出栈为空，则将入栈倒入到出栈中。\n\n``` java\n\tStack<Integer> in = new Stack<Integer>();\n    Stack<Integer> out = new Stack<Integer>();\n\n    public void push(int node) {\n        in.push(node);\n    }\n\n    public int pop() {\n        if (out.isEmpty())\n            while (!in.isEmpty())\n                out.push(in.pop());\n        if (out.isEmpty())\n            return 0;\n        return out.pop();\n    }\n```\n\n\n\n## 斐波那契数列\n\n> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项为1）。\n\n思路：递归效率太低，且占用大量栈内存，使用动态规划来做。\n\n``` java\n    public int Fibonacci(int n) {\n        if (n<2) return n;\n        int[] x=new int[]{0,1};\n        for (int i=2; i<=n; i++)\n            x[i&1]=x[0]+x[1];\n        return x[n&1];\n    }\n```\n\n## 旋转数组的最小数字\n\n> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n思路：二分法，若mid<high，后半为升序，最小值在前半。否则，最小值在后半。还要考虑low、mid、high位置的值相等的情况使用顺序查找。\n\n``` java\n    public int minNumberInRotateArray(int [] array) {\n        if (array.length==0) return 0;\n        int low=0, high=array.length-1;\n        while (low<high){\n            int mid=(low+high)/2;\n            if (array[low]==array[mid]&&array[mid]==array[high]){\n                return minNum(array, low, high);\n            }else if (array[mid]<=array[high]){\n                high=mid;\n            }else {//array[mid]>array[high]\n                low=mid+1;\n            }\n        }\n        return array[low];\n    }\n\t//顺序查找\n    private int minNum(int [] array, int low, int high){\n        int min=low;\n        for (int i=low+1; i<=high; i++){\n            if (array[i]<array[min]){\n                min=i;\n            }\n        }\n        return array[min];\n    }\n```\n\n\n\n## 矩阵中的路径\n\n\n\n\n> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串\"bcced\"的路径，但是矩阵中不包含\"abcb\"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。\n\n\n\n思路：通过二维数组{% raw %}{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}{% endraw %}来上下左右移动，boolean数组判断是否走过\n\n\n\n```java\nprivate final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nprivate int rows;\nprivate int cols;\n\npublic boolean hasPath(char[] array, int rows, int cols, char[] str) {\n    if (rows == 0 || cols == 0)\n        return false;\n    this.rows = rows;\n    this.cols = cols;\n    boolean[][] marked = new boolean[rows][cols];\n    char[][] matrix = buildMatrix(array);\n    for (int i = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            if (backtracking(matrix, str, marked, 0, i, j))\n                return true;\n    return false;\n}\n\nprivate boolean backtracking(char[][] matrix, char[] str, boolean[][] marked, int pathLen, int r, int c) {\n    if (pathLen == str.length)\n        return true;\n    if (r < 0 || r >= rows || c < 0 || c >= cols || matrix[r][c] != str[pathLen] || marked[r][c])\n        return false;\n    marked[r][c] = true;\n    for (int[] n : next)\n        if (backtracking(matrix, str, marked, pathLen + 1, r + n[0], c + n[1]))\n            return true;\n    marked[r][c] = false;\n    return false;\n}\n\nprivate char[][] buildMatrix(char[] array) {\n    char[][] matrix = new char[rows][cols];\n    for (int i = 0, idx = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            matrix[i][j] = array[idx++];\n    return matrix;\n}\n```\n\n\n\n## 机器人的运动范围\n\n\n\n> 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n\n\n\n```java\n    static boolean[][] marked;\n    final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\n    public static int movingCount(int threshold, int rows, int cols){\n        if (rows<=0||cols<=0||threshold<0) return 0;\n        marked = new boolean[rows][cols];\n        return movingCountCore(threshold, rows, cols, 0, 0);\n    }\n\n    private static int movingCountCore(int threshold, int rows, \n                                       int cols, int row, int col){\n        marked[row][col]=true;\n        int ret = 1;\n        for (int[] n : next){\n            int nextRow = row+n[0];\n            int nextCol = col+n[1];\n            if (nextRow < rows && nextRow >= 0 && nextCol < cols && nextCol >= 0 &&\n                    !marked[nextRow][nextCol] && getDigitSum(nextRow, nextCol) <= threshold)\n                ret+=movingCountCore(threshold, rows, cols, nextRow, nextCol);\n        }\n        return ret;\n    }\n    private static int getDigitSum(int row, int col){\n        String r = String.valueOf(row);\n        String c = String.valueOf(col);\n        int ret=0;\n        for (char a:r.toCharArray()) {\n            int b=a-48;\n            ret+=b;\n        }\n        for (char a:c.toCharArray()) {\n            int b=a-48;\n            ret+=b;\n        }\n        return ret;\n    }\n```\n\n\n\n## 剪绳子\n\n\n\n> 把一根绳子剪成多段，并且使得每段的长度乘积最大。\n\n\n\n思路：贪婪算法：尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。\n\n\n\n```java\n    public int integerBreak(int n) {\n        if (n < 2)\n            return 0;\n        if (n == 2)\n            return 1;\n        if (n == 3)\n            return 2;\n        int timesOf3 = n / 3;\n        if (n - timesOf3 * 3 == 1)\n            timesOf3--;\n        int timesOf2 = (n - timesOf3 * 3) / 2;\n        return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));\n    }\n```\n\n\n\n\n\n## 二叉树的镜像\n\n思路：先递归遍历二叉树，再交换左右节点，返回当前根节点\n\n\n``` java\n\tpublic TreeNode Mirror(TreeNode root) {\n\t\tif (root == null)\n\t\t    return null;\n\t\tTreeNode right = null;\n\t\tTreeNode left = null;\n\t\tif (root.left != null)\n\t\t    left = Mirror(root.left);\n\t\tif (root.right != null)\n\t\t    right = Mirror(root.right);\n\t\troot.right = left;\n\t\troot.left = right;\n\t\treturn root;\n\t}\n```\n\n\n\n## 链表中环的入口节点\n\n思路：快慢指针，指针指向地址相等时，将其中一个指针指向头节点，两指针速度相等遍历，相遇时的节点就是环的入口节点\n\n``` java\n    public ListNode EntryNodeOfLoop(ListNode pHead){\n        if (pHead==null||pHead.next==null)\n            return null;\n        ListNode slow=pHead, fast=pHead;\n        do {\n            slow=slow.next;\n            fast=fast.next.next;\n        }while (slow!=fast);\n        slow=pHead;\n        while (slow!=fast){\n            slow=slow.next;\n            fast=fast.next;\n        }\n        return slow;\n    }\n```\n","source":"_posts/剑指Offer题解.md","raw":"---\ntitle: 剑指Offer题解\ndate: 2019-02-18 20:55:23\ncategories: \n\t- Algorithms\n---\n\n## 数组中重复的数字\n\n\n\n> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。\n\n思路：\n\n1. 哈希表,时间复杂度为O(N)，空间复杂度为O(N)\n\n2. 数组中数字都在0到n-1范围内。如果没有重复数字，则每个数字对应其下标。时间复杂度为O(N)，空间复杂度为O(1)\n\n``` java\n    public boolean duplicate(int numbers[],int length,int [] duplication) {\n        if (length<=1 || numbers.length<=1)\n            return false;\n        for (int i=0; i<length; i++){\n            if (numbers[i] != i){\n                if (numbers[numbers[i]]==numbers[i]){\n                    duplication[0]=numbers[i];\n                    return true;\n                }else {\n                    int temp = numbers[numbers[i]];\n                    numbers[numbers[i]] = numbers[i];\n                    numbers[i] = temp;\n                    i--;\n                }\n            }\n        }\n        return false;\n    }\n```\n\n\n\n## 二维数组中的查找\n\n> 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n思路：先检查数组左上角，若大于target，则排除最左列，若小于target，则排除最顶行。\n\n\n``` java\n    public boolean Find(int target, int [][] array) {\n        int x = 0;\n        int y = array[0].length-1;\n        while (x <= array.length-1 && y >= 0){\n            if (array[x][y] == target){\n                return true;\n            }else if (array[x][y] > target){\n                y--;\n            }else { // array[x][y] < target\n                x++;\n            }\n        }\n        return false;\n    }\n```\n\n\n\n## 替换空格\n\n> 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。\n\n思路：先遍历计算空格数量，从后到前移动字符(以保证所有字符只移动一次)。\n\n``` java\n    public String replaceSpace(StringBuffer str) {\n        int length = str.length()-1;\n        for (int i=0; i<=length; i++)\n            if (str.charAt(i) == ' ')\n                str.append(\"  \");\n        for (int i=str.length()-1, j=length; i>=0 && j>=0;){\n            if (str.charAt(j)==' '){\n                str.setCharAt(i--,'0');\n                str.setCharAt(i--,'2');\n                str.setCharAt(i--,'%');\n                j--;\n            }else {\n                str.setCharAt(i,str.charAt(j));\n                i--;\n                j--;\n            }\n        }\n        return str.toString();\n    }\n```\n\n\n\n## 从尾到头打印链表\n\n> 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。\n\n思路：栈的特点是先进后出\n\n``` java\n    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {\n        Stack<Integer> stack = new Stack<>();\n        ArrayList<Integer> ret = new ArrayList<>();\n        while (listNode != null){\n            stack.push(listNode.val);\n            listNode=listNode.next;\n        }\n        while (!stack.empty()){\n            ret.add(stack.pop());\n        }\n        return ret;\n    }\n```\n\n\n\n## 重建二叉树\n\n> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。\n\n思路：前序遍历的第一个值为根节点的值，这个值将中序遍历结果分成两部分，递归。\n\n具体细节：利用HashMap快速查找中序遍历数组的下标\n\n``` java\n\tMap<Integer, Integer> inMap = new HashMap<>();\n    public TreeNode reConstructBinaryTree(int [] pre, int [] in) {\n        for (int i=0; i< in.length; i++)\n            inMap.put(in[i],i);\n        binaryTree(pre, 0,pre.length-1,0);\n    }\n    public TreeNode binaryTree(int [] pre, int pL, int pR, int inIndex) {\n        if (pL>pR) return null;\n        TreeNode root = new TreeNode(pre[pL]);\n        int rootIndex = inMap.get(pre[pL]);\n        int leftTreeLen = rootIndex-inIndex;\n        root.left=binaryTree(pre,pL+1, pL+leftTreeLen, inIndex);\n        root.right=binaryTree(pre, pL+1+leftTreeLen, pR, rootIndex+1);\n        return root;\n    }\n```\n\n\n\n## 二叉树的下一个节点\n\n> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。\n\n思路：分两种情况：1.该节点的右节点不为null时，寻找该右节点的最左子节点/该节点的右节点。2.该节点的右节点为null时，寻找第一个左链接指向的节点包含该节点的祖先节点\n\n``` java\n    public TreeLinkNode GetNext(TreeLinkNode pNode){\n        if (pNode.right != null){\n            pNode=pNode.right;\n            while (pNode.left != null){\n                pNode=pNode.left;\n            }\n            return pNode;\n        }else {// pNode.right==null\n            while (pNode.next != null){\n                TreeLinkNode parent = pNode.next;\n                if (parent.left == pNode)\n                    return parent;\n                pNode=parent;\n            }\n        }\n        return null;\n    }\n```\n\n\n\n## 用两个栈实现队列\n\n> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\n\n思路：一个出栈，一个入栈。若出栈为空，则将入栈倒入到出栈中。\n\n``` java\n\tStack<Integer> in = new Stack<Integer>();\n    Stack<Integer> out = new Stack<Integer>();\n\n    public void push(int node) {\n        in.push(node);\n    }\n\n    public int pop() {\n        if (out.isEmpty())\n            while (!in.isEmpty())\n                out.push(in.pop());\n        if (out.isEmpty())\n            return 0;\n        return out.pop();\n    }\n```\n\n\n\n## 斐波那契数列\n\n> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项为1）。\n\n思路：递归效率太低，且占用大量栈内存，使用动态规划来做。\n\n``` java\n    public int Fibonacci(int n) {\n        if (n<2) return n;\n        int[] x=new int[]{0,1};\n        for (int i=2; i<=n; i++)\n            x[i&1]=x[0]+x[1];\n        return x[n&1];\n    }\n```\n\n## 旋转数组的最小数字\n\n> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。\n\n思路：二分法，若mid<high，后半为升序，最小值在前半。否则，最小值在后半。还要考虑low、mid、high位置的值相等的情况使用顺序查找。\n\n``` java\n    public int minNumberInRotateArray(int [] array) {\n        if (array.length==0) return 0;\n        int low=0, high=array.length-1;\n        while (low<high){\n            int mid=(low+high)/2;\n            if (array[low]==array[mid]&&array[mid]==array[high]){\n                return minNum(array, low, high);\n            }else if (array[mid]<=array[high]){\n                high=mid;\n            }else {//array[mid]>array[high]\n                low=mid+1;\n            }\n        }\n        return array[low];\n    }\n\t//顺序查找\n    private int minNum(int [] array, int low, int high){\n        int min=low;\n        for (int i=low+1; i<=high; i++){\n            if (array[i]<array[min]){\n                min=i;\n            }\n        }\n        return array[min];\n    }\n```\n\n\n\n## 矩阵中的路径\n\n\n\n\n> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串\"bcced\"的路径，但是矩阵中不包含\"abcb\"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。\n\n\n\n思路：通过二维数组{% raw %}{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}{% endraw %}来上下左右移动，boolean数组判断是否走过\n\n\n\n```java\nprivate final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\nprivate int rows;\nprivate int cols;\n\npublic boolean hasPath(char[] array, int rows, int cols, char[] str) {\n    if (rows == 0 || cols == 0)\n        return false;\n    this.rows = rows;\n    this.cols = cols;\n    boolean[][] marked = new boolean[rows][cols];\n    char[][] matrix = buildMatrix(array);\n    for (int i = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            if (backtracking(matrix, str, marked, 0, i, j))\n                return true;\n    return false;\n}\n\nprivate boolean backtracking(char[][] matrix, char[] str, boolean[][] marked, int pathLen, int r, int c) {\n    if (pathLen == str.length)\n        return true;\n    if (r < 0 || r >= rows || c < 0 || c >= cols || matrix[r][c] != str[pathLen] || marked[r][c])\n        return false;\n    marked[r][c] = true;\n    for (int[] n : next)\n        if (backtracking(matrix, str, marked, pathLen + 1, r + n[0], c + n[1]))\n            return true;\n    marked[r][c] = false;\n    return false;\n}\n\nprivate char[][] buildMatrix(char[] array) {\n    char[][] matrix = new char[rows][cols];\n    for (int i = 0, idx = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            matrix[i][j] = array[idx++];\n    return matrix;\n}\n```\n\n\n\n## 机器人的运动范围\n\n\n\n> 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？\n\n\n\n```java\n    static boolean[][] marked;\n    final static int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\n    public static int movingCount(int threshold, int rows, int cols){\n        if (rows<=0||cols<=0||threshold<0) return 0;\n        marked = new boolean[rows][cols];\n        return movingCountCore(threshold, rows, cols, 0, 0);\n    }\n\n    private static int movingCountCore(int threshold, int rows, \n                                       int cols, int row, int col){\n        marked[row][col]=true;\n        int ret = 1;\n        for (int[] n : next){\n            int nextRow = row+n[0];\n            int nextCol = col+n[1];\n            if (nextRow < rows && nextRow >= 0 && nextCol < cols && nextCol >= 0 &&\n                    !marked[nextRow][nextCol] && getDigitSum(nextRow, nextCol) <= threshold)\n                ret+=movingCountCore(threshold, rows, cols, nextRow, nextCol);\n        }\n        return ret;\n    }\n    private static int getDigitSum(int row, int col){\n        String r = String.valueOf(row);\n        String c = String.valueOf(col);\n        int ret=0;\n        for (char a:r.toCharArray()) {\n            int b=a-48;\n            ret+=b;\n        }\n        for (char a:c.toCharArray()) {\n            int b=a-48;\n            ret+=b;\n        }\n        return ret;\n    }\n```\n\n\n\n## 剪绳子\n\n\n\n> 把一根绳子剪成多段，并且使得每段的长度乘积最大。\n\n\n\n思路：贪婪算法：尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。\n\n\n\n```java\n    public int integerBreak(int n) {\n        if (n < 2)\n            return 0;\n        if (n == 2)\n            return 1;\n        if (n == 3)\n            return 2;\n        int timesOf3 = n / 3;\n        if (n - timesOf3 * 3 == 1)\n            timesOf3--;\n        int timesOf2 = (n - timesOf3 * 3) / 2;\n        return (int) (Math.pow(3, timesOf3)) * (int) (Math.pow(2, timesOf2));\n    }\n```\n\n\n\n\n\n## 二叉树的镜像\n\n思路：先递归遍历二叉树，再交换左右节点，返回当前根节点\n\n\n``` java\n\tpublic TreeNode Mirror(TreeNode root) {\n\t\tif (root == null)\n\t\t    return null;\n\t\tTreeNode right = null;\n\t\tTreeNode left = null;\n\t\tif (root.left != null)\n\t\t    left = Mirror(root.left);\n\t\tif (root.right != null)\n\t\t    right = Mirror(root.right);\n\t\troot.right = left;\n\t\troot.left = right;\n\t\treturn root;\n\t}\n```\n\n\n\n## 链表中环的入口节点\n\n思路：快慢指针，指针指向地址相等时，将其中一个指针指向头节点，两指针速度相等遍历，相遇时的节点就是环的入口节点\n\n``` java\n    public ListNode EntryNodeOfLoop(ListNode pHead){\n        if (pHead==null||pHead.next==null)\n            return null;\n        ListNode slow=pHead, fast=pHead;\n        do {\n            slow=slow.next;\n            fast=fast.next.next;\n        }while (slow!=fast);\n        slow=pHead;\n        while (slow!=fast){\n            slow=slow.next;\n            fast=fast.next;\n        }\n        return slow;\n    }\n```\n","slug":"剑指Offer题解","published":1,"updated":"2019-03-06T11:55:35.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdqc000jdcxvfwq8seu3","content":"<h2 id=\"数组中重复的数字\"><a href=\"#数组中重复的数字\" class=\"headerlink\" title=\"数组中重复的数字\"></a>数组中重复的数字</h2><blockquote>\n<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>\n</blockquote>\n<p>思路：</p>\n<ol>\n<li><p>哈希表,时间复杂度为O(N)，空间复杂度为O(N)</p>\n</li>\n<li><p>数组中数字都在0到n-1范围内。如果没有重复数字，则每个数字对应其下标。时间复杂度为O(N)，空间复杂度为O(1)</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">duplicate</span><span class=\"params\">(<span class=\"keyword\">int</span> numbers[],<span class=\"keyword\">int</span> length,<span class=\"keyword\">int</span> [] duplication)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length&lt;=<span class=\"number\">1</span> || numbers.length&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numbers[i] != i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numbers[numbers[i]]==numbers[i])&#123;</span><br><span class=\"line\">                duplication[<span class=\"number\">0</span>]=numbers[i];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = numbers[numbers[i]];</span><br><span class=\"line\">                numbers[numbers[i]] = numbers[i];</span><br><span class=\"line\">                numbers[i] = temp;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二维数组中的查找\"><a href=\"#二维数组中的查找\" class=\"headerlink\" title=\"二维数组中的查找\"></a>二维数组中的查找</h2><blockquote>\n<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n</blockquote>\n<p>思路：先检查数组左上角，若大于target，则排除最左列，若小于target，则排除最顶行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> [][] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y = array[<span class=\"number\">0</span>].length-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x &lt;= array.length-<span class=\"number\">1</span> &amp;&amp; y &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[x][y] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[x][y] &gt; target)&#123;</span><br><span class=\"line\">            y--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// array[x][y] &lt; target</span></span><br><span class=\"line\">            x++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"替换空格\"><a href=\"#替换空格\" class=\"headerlink\" title=\"替换空格\"></a>替换空格</h2><blockquote>\n<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n</blockquote>\n<p>思路：先遍历计算空格数量，从后到前移动字符(以保证所有字符只移动一次)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(StringBuffer str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = str.length()-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=length; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            str.append(<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=str.length()-<span class=\"number\">1</span>, j=length; i&gt;=<span class=\"number\">0</span> &amp;&amp; j&gt;=<span class=\"number\">0</span>;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(j)==<span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'0'</span>);</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'2'</span>);</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'%'</span>);</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            str.setCharAt(i,str.charAt(j));</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从尾到头打印链表\"><a href=\"#从尾到头打印链表\" class=\"headerlink\" title=\"从尾到头打印链表\"></a>从尾到头打印链表</h2><blockquote>\n<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>\n</blockquote>\n<p>思路：栈的特点是先进后出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (listNode != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        stack.push(listNode.val);</span><br><span class=\"line\">        listNode=listNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty())&#123;</span><br><span class=\"line\">        ret.add(stack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重建二叉树\"><a href=\"#重建二叉树\" class=\"headerlink\" title=\"重建二叉树\"></a>重建二叉树</h2><blockquote>\n<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n</blockquote>\n<p>思路：前序遍历的第一个值为根节点的值，这个值将中序遍历结果分成两部分，递归。</p>\n<p>具体细节：利用HashMap快速查找中序遍历数组的下标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Integer&gt; inMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pre, <span class=\"keyword\">int</span> [] in)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt; in.length; i++)</span><br><span class=\"line\">           inMap.put(in[i],i);</span><br><span class=\"line\">       binaryTree(pre, <span class=\"number\">0</span>,pre.length-<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">binaryTree</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pre, <span class=\"keyword\">int</span> pL, <span class=\"keyword\">int</span> pR, <span class=\"keyword\">int</span> inIndex)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (pL&gt;pR) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       TreeNode root = <span class=\"keyword\">new</span> TreeNode(pre[pL]);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> rootIndex = inMap.get(pre[pL]);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> leftTreeLen = rootIndex-inIndex;</span><br><span class=\"line\">       root.left=binaryTree(pre,pL+<span class=\"number\">1</span>, pL+leftTreeLen, inIndex);</span><br><span class=\"line\">       root.right=binaryTree(pre, pL+<span class=\"number\">1</span>+leftTreeLen, pR, rootIndex+<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的下一个节点\"><a href=\"#二叉树的下一个节点\" class=\"headerlink\" title=\"二叉树的下一个节点\"></a>二叉树的下一个节点</h2><blockquote>\n<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>\n</blockquote>\n<p>思路：分两种情况：1.该节点的右节点不为null时，寻找该右节点的最左子节点/该节点的右节点。2.该节点的右节点为null时，寻找第一个左链接指向的节点包含该节点的祖先节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeLinkNode <span class=\"title\">GetNext</span><span class=\"params\">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        pNode=pNode.right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pNode.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            pNode=pNode.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">// pNode.right==null</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pNode.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            TreeLinkNode parent = pNode.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent.left == pNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">            pNode=parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用两个栈实现队列\"><a href=\"#用两个栈实现队列\" class=\"headerlink\" title=\"用两个栈实现队列\"></a>用两个栈实现队列</h2><blockquote>\n<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>\n</blockquote>\n<p>思路：一个出栈，一个入栈。若出栈为空，则将入栈倒入到出栈中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Integer&gt; in = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">   Stack&lt;Integer&gt; out = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">       in.push(node);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (out.isEmpty())</span><br><span class=\"line\">           <span class=\"keyword\">while</span> (!in.isEmpty())</span><br><span class=\"line\">               out.push(in.pop());</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (out.isEmpty())</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> out.pop();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><blockquote>\n<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项为1）。</p>\n</blockquote>\n<p>思路：递归效率太低，且占用大量栈内存，使用动态规划来做。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">Fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n&lt;<span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] x=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=n; i++)</span><br><span class=\"line\">        x[i&amp;<span class=\"number\">1</span>]=x[<span class=\"number\">0</span>]+x[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[n&amp;<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a>旋转数组的最小数字</h2><blockquote>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n</blockquote>\n<p>思路：二分法，若mid&lt;high，后半为升序，最小值在前半。否则，最小值在后半。还要考虑low、mid、high位置的值相等的情况使用顺序查找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (array.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> low=<span class=\"number\">0</span>, high=array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (low&lt;high)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> mid=(low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (array[low]==array[mid]&amp;&amp;array[mid]==array[high])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> minNum(array, low, high);</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[mid]&lt;=array[high])&#123;</span><br><span class=\"line\">               high=mid;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//array[mid]&gt;array[high]</span></span><br><span class=\"line\">               low=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> array[low];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"comment\">//顺序查找</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">minNum</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> min=low;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low+<span class=\"number\">1</span>; i&lt;=high; i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (array[i]&lt;array[min])&#123;</span><br><span class=\"line\">               min=i;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> array[min];</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵中的路径\"><a href=\"#矩阵中的路径\" class=\"headerlink\" title=\"矩阵中的路径\"></a>矩阵中的路径</h2><blockquote>\n<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>\n</blockquote>\n<p>思路：通过二维数组{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}来上下左右移动，boolean数组判断是否走过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] next = &#123;&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rows;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cols;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPath</span><span class=\"params\">(<span class=\"keyword\">char</span>[] array, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">char</span>[] str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rows == <span class=\"number\">0</span> || cols == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.rows = rows;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cols = cols;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] marked = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[][] matrix = buildMatrix(array);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (backtracking(matrix, str, marked, <span class=\"number\">0</span>, i, j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix, <span class=\"keyword\">char</span>[] str, <span class=\"keyword\">boolean</span>[][] marked, <span class=\"keyword\">int</span> pathLen, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pathLen == str.length)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span> || r &gt;= rows || c &lt; <span class=\"number\">0</span> || c &gt;= cols || matrix[r][c] != str[pathLen] || marked[r][c])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    marked[r][c] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] n : next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (backtracking(matrix, str, marked, pathLen + <span class=\"number\">1</span>, r + n[<span class=\"number\">0</span>], c + n[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    marked[r][c] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[][] buildMatrix(<span class=\"keyword\">char</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[][] matrix = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">            matrix[i][j] = array[idx++];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"机器人的运动范围\"><a href=\"#机器人的运动范围\" class=\"headerlink\" title=\"机器人的运动范围\"></a>机器人的运动范围</h2><blockquote>\n<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span>[][] marked;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] next = &#123;&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">movingCount</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rows&lt;=<span class=\"number\">0</span>||cols&lt;=<span class=\"number\">0</span>||threshold&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    marked = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> movingCountCore(threshold, rows, cols, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">movingCountCore</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, <span class=\"keyword\">int</span> rows, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">    marked[row][col]=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] n : next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextRow = row+n[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextCol = col+n[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextRow &lt; rows &amp;&amp; nextRow &gt;= <span class=\"number\">0</span> &amp;&amp; nextCol &lt; cols &amp;&amp; nextCol &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                !marked[nextRow][nextCol] &amp;&amp; getDigitSum(nextRow, nextCol) &lt;= threshold)</span><br><span class=\"line\">            ret+=movingCountCore(threshold, rows, cols, nextRow, nextCol);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDigitSum</span><span class=\"params\">(<span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">    String r = String.valueOf(row);</span><br><span class=\"line\">    String c = String.valueOf(col);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a:r.toCharArray()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b=a-<span class=\"number\">48</span>;</span><br><span class=\"line\">        ret+=b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a:c.toCharArray()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b=a-<span class=\"number\">48</span>;</span><br><span class=\"line\">        ret+=b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"剪绳子\"><a href=\"#剪绳子\" class=\"headerlink\" title=\"剪绳子\"></a>剪绳子</h2><blockquote>\n<p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>\n</blockquote>\n<p>思路：贪婪算法：尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">integerBreak</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timesOf3 = n / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n - timesOf3 * <span class=\"number\">3</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">        timesOf3--;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timesOf2 = (n - timesOf3 * <span class=\"number\">3</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (Math.pow(<span class=\"number\">3</span>, timesOf3)) * (<span class=\"keyword\">int</span>) (Math.pow(<span class=\"number\">2</span>, timesOf2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><p>思路：先递归遍历二叉树，再交换左右节点，返回当前根节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">Mirror</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    left = Mirror(root.left);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    right = Mirror(root.right);</span><br><span class=\"line\">\troot.right = left;</span><br><span class=\"line\">\troot.left = right;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"链表中环的入口节点\"><a href=\"#链表中环的入口节点\" class=\"headerlink\" title=\"链表中环的入口节点\"></a>链表中环的入口节点</h2><p>思路：快慢指针，指针指向地址相等时，将其中一个指针指向头节点，两指针速度相等遍历，相遇时的节点就是环的入口节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">EntryNodeOfLoop</span><span class=\"params\">(ListNode pHead)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pHead==<span class=\"keyword\">null</span>||pHead.next==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    ListNode slow=pHead, fast=pHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        slow=slow.next;</span><br><span class=\"line\">        fast=fast.next.next;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span> (slow!=fast);</span><br><span class=\"line\">    slow=pHead;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (slow!=fast)&#123;</span><br><span class=\"line\">        slow=slow.next;</span><br><span class=\"line\">        fast=fast.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数组中重复的数字\"><a href=\"#数组中重复的数字\" class=\"headerlink\" title=\"数组中重复的数字\"></a>数组中重复的数字</h2><blockquote>\n<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>\n</blockquote>\n<p>思路：</p>\n<ol>\n<li><p>哈希表,时间复杂度为O(N)，空间复杂度为O(N)</p>\n</li>\n<li><p>数组中数字都在0到n-1范围内。如果没有重复数字，则每个数字对应其下标。时间复杂度为O(N)，空间复杂度为O(1)</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">duplicate</span><span class=\"params\">(<span class=\"keyword\">int</span> numbers[],<span class=\"keyword\">int</span> length,<span class=\"keyword\">int</span> [] duplication)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length&lt;=<span class=\"number\">1</span> || numbers.length&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (numbers[i] != i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numbers[numbers[i]]==numbers[i])&#123;</span><br><span class=\"line\">                duplication[<span class=\"number\">0</span>]=numbers[i];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = numbers[numbers[i]];</span><br><span class=\"line\">                numbers[numbers[i]] = numbers[i];</span><br><span class=\"line\">                numbers[i] = temp;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二维数组中的查找\"><a href=\"#二维数组中的查找\" class=\"headerlink\" title=\"二维数组中的查找\"></a>二维数组中的查找</h2><blockquote>\n<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n</blockquote>\n<p>思路：先检查数组左上角，若大于target，则排除最左列，若小于target，则排除最顶行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">Find</span><span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> [][] array)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y = array[<span class=\"number\">0</span>].length-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x &lt;= array.length-<span class=\"number\">1</span> &amp;&amp; y &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array[x][y] == target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[x][y] &gt; target)&#123;</span><br><span class=\"line\">            y--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// array[x][y] &lt; target</span></span><br><span class=\"line\">            x++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"替换空格\"><a href=\"#替换空格\" class=\"headerlink\" title=\"替换空格\"></a>替换空格</h2><blockquote>\n<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>\n</blockquote>\n<p>思路：先遍历计算空格数量，从后到前移动字符(以保证所有字符只移动一次)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(StringBuffer str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = str.length()-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=length; i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(i) == <span class=\"string\">' '</span>)</span><br><span class=\"line\">            str.append(<span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=str.length()-<span class=\"number\">1</span>, j=length; i&gt;=<span class=\"number\">0</span> &amp;&amp; j&gt;=<span class=\"number\">0</span>;)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str.charAt(j)==<span class=\"string\">' '</span>)&#123;</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'0'</span>);</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'2'</span>);</span><br><span class=\"line\">            str.setCharAt(i--,<span class=\"string\">'%'</span>);</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            str.setCharAt(i,str.charAt(j));</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从尾到头打印链表\"><a href=\"#从尾到头打印链表\" class=\"headerlink\" title=\"从尾到头打印链表\"></a>从尾到头打印链表</h2><blockquote>\n<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>\n</blockquote>\n<p>思路：栈的特点是先进后出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ArrayList&lt;Integer&gt; <span class=\"title\">printListFromTailToHead</span><span class=\"params\">(ListNode listNode)</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (listNode != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        stack.push(listNode.val);</span><br><span class=\"line\">        listNode=listNode.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.empty())&#123;</span><br><span class=\"line\">        ret.add(stack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重建二叉树\"><a href=\"#重建二叉树\" class=\"headerlink\" title=\"重建二叉树\"></a>重建二叉树</h2><blockquote>\n<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>\n</blockquote>\n<p>思路：前序遍历的第一个值为根节点的值，这个值将中序遍历结果分成两部分，递归。</p>\n<p>具体细节：利用HashMap快速查找中序遍历数组的下标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, Integer&gt; inMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">reConstructBinaryTree</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pre, <span class=\"keyword\">int</span> [] in)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt; in.length; i++)</span><br><span class=\"line\">           inMap.put(in[i],i);</span><br><span class=\"line\">       binaryTree(pre, <span class=\"number\">0</span>,pre.length-<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">binaryTree</span><span class=\"params\">(<span class=\"keyword\">int</span> [] pre, <span class=\"keyword\">int</span> pL, <span class=\"keyword\">int</span> pR, <span class=\"keyword\">int</span> inIndex)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (pL&gt;pR) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       TreeNode root = <span class=\"keyword\">new</span> TreeNode(pre[pL]);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> rootIndex = inMap.get(pre[pL]);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> leftTreeLen = rootIndex-inIndex;</span><br><span class=\"line\">       root.left=binaryTree(pre,pL+<span class=\"number\">1</span>, pL+leftTreeLen, inIndex);</span><br><span class=\"line\">       root.right=binaryTree(pre, pL+<span class=\"number\">1</span>+leftTreeLen, pR, rootIndex+<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的下一个节点\"><a href=\"#二叉树的下一个节点\" class=\"headerlink\" title=\"二叉树的下一个节点\"></a>二叉树的下一个节点</h2><blockquote>\n<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>\n</blockquote>\n<p>思路：分两种情况：1.该节点的右节点不为null时，寻找该右节点的最左子节点/该节点的右节点。2.该节点的右节点为null时，寻找第一个左链接指向的节点包含该节点的祖先节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeLinkNode <span class=\"title\">GetNext</span><span class=\"params\">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pNode.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        pNode=pNode.right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pNode.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            pNode=pNode.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pNode;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">// pNode.right==null</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pNode.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            TreeLinkNode parent = pNode.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent.left == pNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">            pNode=parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"用两个栈实现队列\"><a href=\"#用两个栈实现队列\" class=\"headerlink\" title=\"用两个栈实现队列\"></a>用两个栈实现队列</h2><blockquote>\n<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>\n</blockquote>\n<p>思路：一个出栈，一个入栈。若出栈为空，则将入栈倒入到出栈中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Integer&gt; in = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">   Stack&lt;Integer&gt; out = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">       in.push(node);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (out.isEmpty())</span><br><span class=\"line\">           <span class=\"keyword\">while</span> (!in.isEmpty())</span><br><span class=\"line\">               out.push(in.pop());</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (out.isEmpty())</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> out.pop();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h2><blockquote>\n<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项为1）。</p>\n</blockquote>\n<p>思路：递归效率太低，且占用大量栈内存，使用动态规划来做。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">Fibonacci</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n&lt;<span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] x=<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>; i&lt;=n; i++)</span><br><span class=\"line\">        x[i&amp;<span class=\"number\">1</span>]=x[<span class=\"number\">0</span>]+x[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x[n&amp;<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a>旋转数组的最小数字</h2><blockquote>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>\n</blockquote>\n<p>思路：二分法，若mid&lt;high，后半为升序，最小值在前半。否则，最小值在后半。还要考虑low、mid、high位置的值相等的情况使用顺序查找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minNumberInRotateArray</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (array.length==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> low=<span class=\"number\">0</span>, high=array.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (low&lt;high)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> mid=(low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (array[low]==array[mid]&amp;&amp;array[mid]==array[high])&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> minNum(array, low, high);</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (array[mid]&lt;=array[high])&#123;</span><br><span class=\"line\">               high=mid;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> &#123;<span class=\"comment\">//array[mid]&gt;array[high]</span></span><br><span class=\"line\">               low=mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> array[low];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"comment\">//顺序查找</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">minNum</span><span class=\"params\">(<span class=\"keyword\">int</span> [] array, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> min=low;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low+<span class=\"number\">1</span>; i&lt;=high; i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (array[i]&lt;array[min])&#123;</span><br><span class=\"line\">               min=i;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> array[min];</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"矩阵中的路径\"><a href=\"#矩阵中的路径\" class=\"headerlink\" title=\"矩阵中的路径\"></a>矩阵中的路径</h2><blockquote>\n<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>\n</blockquote>\n<p>思路：通过二维数组{{0, -1}, {0, 1}, {-1, 0}, {1, 0}}来上下左右移动，boolean数组判断是否走过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] next = &#123;&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> rows;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cols;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPath</span><span class=\"params\">(<span class=\"keyword\">char</span>[] array, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">char</span>[] str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rows == <span class=\"number\">0</span> || cols == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.rows = rows;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cols = cols;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span>[][] marked = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[][] matrix = buildMatrix(array);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (backtracking(matrix, str, marked, <span class=\"number\">0</span>, i, j))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">backtracking</span><span class=\"params\">(<span class=\"keyword\">char</span>[][] matrix, <span class=\"keyword\">char</span>[] str, <span class=\"keyword\">boolean</span>[][] marked, <span class=\"keyword\">int</span> pathLen, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pathLen == str.length)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span> || r &gt;= rows || c &lt; <span class=\"number\">0</span> || c &gt;= cols || matrix[r][c] != str[pathLen] || marked[r][c])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    marked[r][c] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] n : next)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (backtracking(matrix, str, marked, pathLen + <span class=\"number\">1</span>, r + n[<span class=\"number\">0</span>], c + n[<span class=\"number\">1</span>]))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    marked[r][c] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">char</span>[][] buildMatrix(<span class=\"keyword\">char</span>[] array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[][] matrix = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, idx = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">            matrix[i][j] = array[idx++];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> matrix;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"机器人的运动范围\"><a href=\"#机器人的运动范围\" class=\"headerlink\" title=\"机器人的运动范围\"></a>机器人的运动范围</h2><blockquote>\n<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span>[][] marked;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[][] next = &#123;&#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">movingCount</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rows&lt;=<span class=\"number\">0</span>||cols&lt;=<span class=\"number\">0</span>||threshold&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    marked = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[rows][cols];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> movingCountCore(threshold, rows, cols, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">movingCountCore</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, <span class=\"keyword\">int</span> rows, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">    marked[row][col]=<span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] n : next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextRow = row+n[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextCol = col+n[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextRow &lt; rows &amp;&amp; nextRow &gt;= <span class=\"number\">0</span> &amp;&amp; nextCol &lt; cols &amp;&amp; nextCol &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                !marked[nextRow][nextCol] &amp;&amp; getDigitSum(nextRow, nextCol) &lt;= threshold)</span><br><span class=\"line\">            ret+=movingCountCore(threshold, rows, cols, nextRow, nextCol);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDigitSum</span><span class=\"params\">(<span class=\"keyword\">int</span> row, <span class=\"keyword\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">    String r = String.valueOf(row);</span><br><span class=\"line\">    String c = String.valueOf(col);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a:r.toCharArray()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b=a-<span class=\"number\">48</span>;</span><br><span class=\"line\">        ret+=b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> a:c.toCharArray()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b=a-<span class=\"number\">48</span>;</span><br><span class=\"line\">        ret+=b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"剪绳子\"><a href=\"#剪绳子\" class=\"headerlink\" title=\"剪绳子\"></a>剪绳子</h2><blockquote>\n<p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>\n</blockquote>\n<p>思路：贪婪算法：尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">integerBreak</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">3</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timesOf3 = n / <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n - timesOf3 * <span class=\"number\">3</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">        timesOf3--;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timesOf2 = (n - timesOf3 * <span class=\"number\">3</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">int</span>) (Math.pow(<span class=\"number\">3</span>, timesOf3)) * (<span class=\"keyword\">int</span>) (Math.pow(<span class=\"number\">2</span>, timesOf2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的镜像\"><a href=\"#二叉树的镜像\" class=\"headerlink\" title=\"二叉树的镜像\"></a>二叉树的镜像</h2><p>思路：先递归遍历二叉树，再交换左右节点，返回当前根节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">Mirror</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\tTreeNode left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    left = Mirror(root.left);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t    right = Mirror(root.right);</span><br><span class=\"line\">\troot.right = left;</span><br><span class=\"line\">\troot.left = right;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"链表中环的入口节点\"><a href=\"#链表中环的入口节点\" class=\"headerlink\" title=\"链表中环的入口节点\"></a>链表中环的入口节点</h2><p>思路：快慢指针，指针指向地址相等时，将其中一个指针指向头节点，两指针速度相等遍历，相遇时的节点就是环的入口节点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">EntryNodeOfLoop</span><span class=\"params\">(ListNode pHead)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pHead==<span class=\"keyword\">null</span>||pHead.next==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    ListNode slow=pHead, fast=pHead;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        slow=slow.next;</span><br><span class=\"line\">        fast=fast.next.next;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span> (slow!=fast);</span><br><span class=\"line\">    slow=pHead;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (slow!=fast)&#123;</span><br><span class=\"line\">        slow=slow.next;</span><br><span class=\"line\">        fast=fast.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"对G1算法和G1垃圾回收器的理解","date":"2019-01-06T09:09:39.000Z","_content":"\nG1(Garbage-First )垃圾回收算法，HotspotVM的四种GC算法之一。\nG1垃圾回收器启动参数-XX:+UseG1GC，Java 9开始被作为默认垃圾回收器。\n这里基于读者已经了解其他三种GC算法，我作为一个blog搬运工(关于G1算法的优秀blog请看参考资料)，谈一下对G1算法的总结和理解思路。\n\n\n基本概念\n---\n\n<h4>GC算法中的并行和并发</h4>\n\n并发(concurrent):通常指GC线程与应用程序线程宏观上看是一起执行的\n\n并行(parallel):指多个线程进行垃圾回收，此时应用程序线程是暂停的\n\n<h4>三色标记</h4>\n\n黑色:该对象与它的子对象都被扫描\n\n灰色:对象本身被扫描,但还没扫描完该对象中的子对象\n\n白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象\n\n<h4>RSet(remembered set)</h4>\n\n该集合用来记录并跟踪其它region指向该region中对象的引用，使统计region中存活对象的效率更高\n\n<h4>CSet(collection set)</h4>\n\n记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。\n\n<h4>SATB</h4>\n\nSATB全称snapshot-at-the-beginning，SATB保证了在并发标记过程中新分配对象不会漏标\n\n（1）**SATB工作的具体过程**\n\n<img src=\"/images/satb.png\" width=\"50%\" height=\"50%\">\n\n1. [top, end]区域为空闲区，top向右移来给对象在[next TAMS, top]之间分配内存\n2. 并发标记在[previous TAMS, next TAMS]区间进行，并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照Bitmap，所有垃圾对象能通过快照被识别出来\n3. 下一轮开始时，将top所在的地址赋值给next TAMS\n\n（2）**SATB write barrier如何解决白色对象被漏标**\n\n(引用自[<font color=#0000CD>[HotSpot VM] 关于incremental update与SATB的一点理解</font>](https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529))\n\n> 一个white对象在并发标记阶段会被漏标的充分必要条件是： \n> \n> 1、mutator插入了一个从black对象到该white对象的新引用 \n> \n> 2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。 \n> \n> 因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 \n>\n> Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。\n> \n> SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。\n\n（3）**Write barrier功能**\n\n1. 跨region的引用同步到RSet里\n2. 同步SATB快照的完整性\n\n分代G1算法\n---\n\nG1算法引入了region，分区young gen和old gen没有明确的界限，当新建对象大小超过region大小一半时，直接在新的一个或多个连续region中分配，并标记为Humongous,为巨型对象。\n\n<img src=\"/images/G1Gen.png\" width=\"50%\" height=\"50%\">\n\n把GC过程分成 **global concurrent marking** 和 **evacuation** 两个阶段且相互独立执行的理解更友好。其他的思路我也看过，将GC分为四个阶段，最后一个阶段是筛选回收，这种理解方法并不好，因为真正回收内存的操作并不一定是紧接着在完成所有标记之后。\n\n<h3>global concurrent marking 基于SATB</h3>\n\n1. **初始标记（initial marking）**<font color=#DC143C>暂停阶段</font>\n从GC Roots开始标记直接可达的对象。在G1垃圾回收器中还会存在young GC，这个阶段借用了young GC的暂停\n\n2. **并发标记（concurrent marking）**<font color=#008000>并发阶段</font>\n从GC Roots开始对堆中的对象标记，标记线程与应用程序线程并行执行，这个过程基于SATB。还会伴随着扫描SATB write barrier记录的引用变化\n\n3. **最终标记（final marking / remarking）**<font color=#DC143C>暂停阶段</font>\n处理还未扫描完的SATB write barrier。CMS的remark阶段扫描的是INC write barrier，由于这个无法发现Concurrent Mark期间堆外根集（寄存器、栈）的引用变化，所以CMS的remark阶段可能会很慢。\n\n4. **筛选回收（cleanup）**\n在SATB的Bitmap中统计各个region中存活对象，擦除RSet(<font color=#DC143C>Stop the World</font>)。重置空白区域并将其返回到空闲列表(<font color=#008000>并发执行</font>)\n\n\n<h3>evacuation</h3>\t\n<font color=#DC143C>暂停阶段</font>\n选定需要回收的region加入到CSet中，并行地把CSet中每个region的活对象拷贝到新的region里。\n\n<h3>G1 GC选取CSet的模式</h3>\n\n1. Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。 \n2. Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。\n3. Full GC：确切地说Full GC算是一种异常情况下的GC，当Mixed GC无法跟上应用程序分配内存的速度时，Java 9及之前会切换到serial old GC/Java 10开始多线程并行，来收集整个GC heap(该GC heap包括Java 7及之前的perm)。\n**触发Full GC的情况**：global concurrent marking时old gen被填满；对象晋升失败；巨型对象分配失败\n\nG1垃圾回收器\n---\n\n<h3>G1 GC的优点</h3>\n\n1. 可预测停顿，维护CSet来尽量使停顿时间小于用户设置的MaxGCPauseMillis。\n2. 基于SATB效率高，remark阶段使用SATB write barrier比CMS的INC write barrier效率高，易于控制停顿\n3. 并行与并发结合\n4. 整合空间，引入region来划分堆，没有了复制算法浪费内存和标记清除法存在大量内存碎片的问题\n\n<h3>G1 GC适合在什么场景下使用?</h3>\n\n1. 堆内存较大\n2. Full-GC执行太频繁，或者持续的时间太长\n3. GC暂停时间太长\n4. 对象分配的速度差距较大\n\n<h3>G1 GC常用参数解释</h3>\n\n> 具体参数及解释查看[<font color=#0000CD>垃圾优先型垃圾回收器调优</font>](https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html)\n>\n> -XX:MaxGCPauseMillis=200 设置GC的最大暂停时间为200ms。\n> \n> -XX:G1HeapRegionSize=n 设置的region区域的大小。值是2的n次幂，范围是1MB到32MB之间。\n> \n> -XX:ParallelGCThreads=n 设置STW工作线程数的值。\n> \n> -XX:ConcGCThreads=n 设置并行标记的线程数。\n> \n> -XX:InitiatingHeapOccupancyPercent=45 设置触发标记周期的Java堆占用率阈值。默认占用率是整个Java堆的45%。\n> \n> -XX:G1ReservePercent=10 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%\n\n<h3>G1 GC调优</h3>\n\n参考[<font color=#0000CD>G1垃圾收集器(六) 之 命令行选项和最佳实践</font>](https://zhaoyanblog.com/archives/440.html)\n\n1. 不设置young gen大小。通过参数显式设置young gen大小可能会使设定的pause time失效。G1是通过控制young gen的region个数来控制young GC的开销。\n2. MaxGCPauseMillis停顿时间应考虑设置90%以上时间都能达到目标的值。因为MaxGCPauseMillis是最大停顿时间，可以保证大部分停顿时间在设定范围内。\n3. 有关溢出和用尽的日志消息的问题解决。(没有足够的内存，供存活者和/或晋升对象使用。Java堆不能扩展，因为已达到最大值。)\n\t- 增加 -XX:G1ReservePercent=n 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量，默认是10。\n\n\t- 减少 -XX:InitiatingHeapOccupancyPercent=45 提前启动标记周期，默认占用率是整个Java堆的 45%。\n\n\t- 增加 -XX:ConcGCThreads=n 选项的值来增加并行标记线程的数目。\n\n\n参考资料：\n---\n\n- [<font color=#0000CD>[HotSpot VM] 请教G1算法的原理</font>](https://hllvm-group.iteye.com/group/topic/44381#post-272188)\n- [<font color=#0000CD>[HotSpot VM] 关于incremental update与SATB的一点理解</font>](https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529)\n- [<font color=#0000CD>可能是最全面的G1学习笔记 - 阿杜的世界</font>](https://cloud.tencent.com/developer/article/1378263)\n- [<font color=#0000CD>Getting Started with the G1 Garbage Collector - Oracle</font>](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)\n- [<font color=#0000CD>Java Hotspot G1 GC的一些关键技术 - 美团技术团队</font>](https://tech.meituan.com/g1.html)\n- [<font color=#0000CD>深入理解Java G1垃圾收集器</font>](https://www.jianshu.com/p/d302ed6e2405)\n- [<font color=#0000CD>垃圾优先型垃圾回收器调优</font>](https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html)","source":"_posts/对G1算法和G1垃圾回收器的理解.md","raw":"---\ntitle: 对G1算法和G1垃圾回收器的理解\ndate: 2019-01-06 17:09:39\ncategories: \n\t- JVM\n---\n\nG1(Garbage-First )垃圾回收算法，HotspotVM的四种GC算法之一。\nG1垃圾回收器启动参数-XX:+UseG1GC，Java 9开始被作为默认垃圾回收器。\n这里基于读者已经了解其他三种GC算法，我作为一个blog搬运工(关于G1算法的优秀blog请看参考资料)，谈一下对G1算法的总结和理解思路。\n\n\n基本概念\n---\n\n<h4>GC算法中的并行和并发</h4>\n\n并发(concurrent):通常指GC线程与应用程序线程宏观上看是一起执行的\n\n并行(parallel):指多个线程进行垃圾回收，此时应用程序线程是暂停的\n\n<h4>三色标记</h4>\n\n黑色:该对象与它的子对象都被扫描\n\n灰色:对象本身被扫描,但还没扫描完该对象中的子对象\n\n白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象\n\n<h4>RSet(remembered set)</h4>\n\n该集合用来记录并跟踪其它region指向该region中对象的引用，使统计region中存活对象的效率更高\n\n<h4>CSet(collection set)</h4>\n\n记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。\n\n<h4>SATB</h4>\n\nSATB全称snapshot-at-the-beginning，SATB保证了在并发标记过程中新分配对象不会漏标\n\n（1）**SATB工作的具体过程**\n\n<img src=\"/images/satb.png\" width=\"50%\" height=\"50%\">\n\n1. [top, end]区域为空闲区，top向右移来给对象在[next TAMS, top]之间分配内存\n2. 并发标记在[previous TAMS, next TAMS]区间进行，并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照Bitmap，所有垃圾对象能通过快照被识别出来\n3. 下一轮开始时，将top所在的地址赋值给next TAMS\n\n（2）**SATB write barrier如何解决白色对象被漏标**\n\n(引用自[<font color=#0000CD>[HotSpot VM] 关于incremental update与SATB的一点理解</font>](https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529))\n\n> 一个white对象在并发标记阶段会被漏标的充分必要条件是： \n> \n> 1、mutator插入了一个从black对象到该white对象的新引用 \n> \n> 2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。 \n> \n> 因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 \n>\n> Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。\n> \n> SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。\n\n（3）**Write barrier功能**\n\n1. 跨region的引用同步到RSet里\n2. 同步SATB快照的完整性\n\n分代G1算法\n---\n\nG1算法引入了region，分区young gen和old gen没有明确的界限，当新建对象大小超过region大小一半时，直接在新的一个或多个连续region中分配，并标记为Humongous,为巨型对象。\n\n<img src=\"/images/G1Gen.png\" width=\"50%\" height=\"50%\">\n\n把GC过程分成 **global concurrent marking** 和 **evacuation** 两个阶段且相互独立执行的理解更友好。其他的思路我也看过，将GC分为四个阶段，最后一个阶段是筛选回收，这种理解方法并不好，因为真正回收内存的操作并不一定是紧接着在完成所有标记之后。\n\n<h3>global concurrent marking 基于SATB</h3>\n\n1. **初始标记（initial marking）**<font color=#DC143C>暂停阶段</font>\n从GC Roots开始标记直接可达的对象。在G1垃圾回收器中还会存在young GC，这个阶段借用了young GC的暂停\n\n2. **并发标记（concurrent marking）**<font color=#008000>并发阶段</font>\n从GC Roots开始对堆中的对象标记，标记线程与应用程序线程并行执行，这个过程基于SATB。还会伴随着扫描SATB write barrier记录的引用变化\n\n3. **最终标记（final marking / remarking）**<font color=#DC143C>暂停阶段</font>\n处理还未扫描完的SATB write barrier。CMS的remark阶段扫描的是INC write barrier，由于这个无法发现Concurrent Mark期间堆外根集（寄存器、栈）的引用变化，所以CMS的remark阶段可能会很慢。\n\n4. **筛选回收（cleanup）**\n在SATB的Bitmap中统计各个region中存活对象，擦除RSet(<font color=#DC143C>Stop the World</font>)。重置空白区域并将其返回到空闲列表(<font color=#008000>并发执行</font>)\n\n\n<h3>evacuation</h3>\t\n<font color=#DC143C>暂停阶段</font>\n选定需要回收的region加入到CSet中，并行地把CSet中每个region的活对象拷贝到新的region里。\n\n<h3>G1 GC选取CSet的模式</h3>\n\n1. Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。 \n2. Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。\n3. Full GC：确切地说Full GC算是一种异常情况下的GC，当Mixed GC无法跟上应用程序分配内存的速度时，Java 9及之前会切换到serial old GC/Java 10开始多线程并行，来收集整个GC heap(该GC heap包括Java 7及之前的perm)。\n**触发Full GC的情况**：global concurrent marking时old gen被填满；对象晋升失败；巨型对象分配失败\n\nG1垃圾回收器\n---\n\n<h3>G1 GC的优点</h3>\n\n1. 可预测停顿，维护CSet来尽量使停顿时间小于用户设置的MaxGCPauseMillis。\n2. 基于SATB效率高，remark阶段使用SATB write barrier比CMS的INC write barrier效率高，易于控制停顿\n3. 并行与并发结合\n4. 整合空间，引入region来划分堆，没有了复制算法浪费内存和标记清除法存在大量内存碎片的问题\n\n<h3>G1 GC适合在什么场景下使用?</h3>\n\n1. 堆内存较大\n2. Full-GC执行太频繁，或者持续的时间太长\n3. GC暂停时间太长\n4. 对象分配的速度差距较大\n\n<h3>G1 GC常用参数解释</h3>\n\n> 具体参数及解释查看[<font color=#0000CD>垃圾优先型垃圾回收器调优</font>](https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html)\n>\n> -XX:MaxGCPauseMillis=200 设置GC的最大暂停时间为200ms。\n> \n> -XX:G1HeapRegionSize=n 设置的region区域的大小。值是2的n次幂，范围是1MB到32MB之间。\n> \n> -XX:ParallelGCThreads=n 设置STW工作线程数的值。\n> \n> -XX:ConcGCThreads=n 设置并行标记的线程数。\n> \n> -XX:InitiatingHeapOccupancyPercent=45 设置触发标记周期的Java堆占用率阈值。默认占用率是整个Java堆的45%。\n> \n> -XX:G1ReservePercent=10 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%\n\n<h3>G1 GC调优</h3>\n\n参考[<font color=#0000CD>G1垃圾收集器(六) 之 命令行选项和最佳实践</font>](https://zhaoyanblog.com/archives/440.html)\n\n1. 不设置young gen大小。通过参数显式设置young gen大小可能会使设定的pause time失效。G1是通过控制young gen的region个数来控制young GC的开销。\n2. MaxGCPauseMillis停顿时间应考虑设置90%以上时间都能达到目标的值。因为MaxGCPauseMillis是最大停顿时间，可以保证大部分停顿时间在设定范围内。\n3. 有关溢出和用尽的日志消息的问题解决。(没有足够的内存，供存活者和/或晋升对象使用。Java堆不能扩展，因为已达到最大值。)\n\t- 增加 -XX:G1ReservePercent=n 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量，默认是10。\n\n\t- 减少 -XX:InitiatingHeapOccupancyPercent=45 提前启动标记周期，默认占用率是整个Java堆的 45%。\n\n\t- 增加 -XX:ConcGCThreads=n 选项的值来增加并行标记线程的数目。\n\n\n参考资料：\n---\n\n- [<font color=#0000CD>[HotSpot VM] 请教G1算法的原理</font>](https://hllvm-group.iteye.com/group/topic/44381#post-272188)\n- [<font color=#0000CD>[HotSpot VM] 关于incremental update与SATB的一点理解</font>](https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529)\n- [<font color=#0000CD>可能是最全面的G1学习笔记 - 阿杜的世界</font>](https://cloud.tencent.com/developer/article/1378263)\n- [<font color=#0000CD>Getting Started with the G1 Garbage Collector - Oracle</font>](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)\n- [<font color=#0000CD>Java Hotspot G1 GC的一些关键技术 - 美团技术团队</font>](https://tech.meituan.com/g1.html)\n- [<font color=#0000CD>深入理解Java G1垃圾收集器</font>](https://www.jianshu.com/p/d302ed6e2405)\n- [<font color=#0000CD>垃圾优先型垃圾回收器调优</font>](https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html)","slug":"对G1算法和G1垃圾回收器的理解","published":1,"updated":"2019-01-09T09:23:15.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtrzgdqf000ldcxvr7lsjhpj","content":"<p>G1(Garbage-First )垃圾回收算法，HotspotVM的四种GC算法之一。<br>G1垃圾回收器启动参数-XX:+UseG1GC，Java 9开始被作为默认垃圾回收器。<br>这里基于读者已经了解其他三种GC算法，我作为一个blog搬运工(关于G1算法的优秀blog请看参考资料)，谈一下对G1算法的总结和理解思路。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h4>GC算法中的并行和并发</h4>\n\n<p>并发(concurrent):通常指GC线程与应用程序线程宏观上看是一起执行的</p>\n<p>并行(parallel):指多个线程进行垃圾回收，此时应用程序线程是暂停的</p>\n<h4>三色标记</h4>\n\n<p>黑色:该对象与它的子对象都被扫描</p>\n<p>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</p>\n<p>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</p>\n<h4>RSet(remembered set)</h4>\n\n<p>该集合用来记录并跟踪其它region指向该region中对象的引用，使统计region中存活对象的效率更高</p>\n<h4>CSet(collection set)</h4>\n\n<p>记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old-&gt;young和old-&gt;old的跨代对象引用，只要扫描对应的CSet中的RSet即可。</p>\n<h4>SATB</h4>\n\n<p>SATB全称snapshot-at-the-beginning，SATB保证了在并发标记过程中新分配对象不会漏标</p>\n<p>（1）<strong>SATB工作的具体过程</strong></p>\n<p><img src=\"/images/satb.png\" width=\"50%\" height=\"50%\"></p>\n<ol>\n<li>[top, end]区域为空闲区，top向右移来给对象在[next TAMS, top]之间分配内存</li>\n<li>并发标记在[previous TAMS, next TAMS]区间进行，并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照Bitmap，所有垃圾对象能通过快照被识别出来</li>\n<li>下一轮开始时，将top所在的地址赋值给next TAMS</li>\n</ol>\n<p>（2）<strong>SATB write barrier如何解决白色对象被漏标</strong></p>\n<p>(引用自<a href=\"https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 关于incremental update与SATB的一点理解</font></a>)</p>\n<blockquote>\n<p>一个white对象在并发标记阶段会被漏标的充分必要条件是： </p>\n<p>1、mutator插入了一个从black对象到该white对象的新引用 </p>\n<p>2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。 </p>\n<p>因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 </p>\n<p>Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。</p>\n<p>SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。</p>\n</blockquote>\n<p>（3）<strong>Write barrier功能</strong></p>\n<ol>\n<li>跨region的引用同步到RSet里</li>\n<li>同步SATB快照的完整性</li>\n</ol>\n<h2 id=\"分代G1算法\"><a href=\"#分代G1算法\" class=\"headerlink\" title=\"分代G1算法\"></a>分代G1算法</h2><p>G1算法引入了region，分区young gen和old gen没有明确的界限，当新建对象大小超过region大小一半时，直接在新的一个或多个连续region中分配，并标记为Humongous,为巨型对象。</p>\n<p><img src=\"/images/G1Gen.png\" width=\"50%\" height=\"50%\"></p>\n<p>把GC过程分成 <strong>global concurrent marking</strong> 和 <strong>evacuation</strong> 两个阶段且相互独立执行的理解更友好。其他的思路我也看过，将GC分为四个阶段，最后一个阶段是筛选回收，这种理解方法并不好，因为真正回收内存的操作并不一定是紧接着在完成所有标记之后。</p>\n<h3>global concurrent marking 基于SATB</h3>\n\n<ol>\n<li><p><strong>初始标记（initial marking）</strong><font color=\"#DC143C\">暂停阶段</font><br>从GC Roots开始标记直接可达的对象。在G1垃圾回收器中还会存在young GC，这个阶段借用了young GC的暂停</p>\n</li>\n<li><p><strong>并发标记（concurrent marking）</strong><font color=\"#008000\">并发阶段</font><br>从GC Roots开始对堆中的对象标记，标记线程与应用程序线程并行执行，这个过程基于SATB。还会伴随着扫描SATB write barrier记录的引用变化</p>\n</li>\n<li><p><strong>最终标记（final marking / remarking）</strong><font color=\"#DC143C\">暂停阶段</font><br>处理还未扫描完的SATB write barrier。CMS的remark阶段扫描的是INC write barrier，由于这个无法发现Concurrent Mark期间堆外根集（寄存器、栈）的引用变化，所以CMS的remark阶段可能会很慢。</p>\n</li>\n<li><p><strong>筛选回收（cleanup）</strong><br>在SATB的Bitmap中统计各个region中存活对象，擦除RSet(<font color=\"#DC143C\">Stop the World</font>)。重置空白区域并将其返回到空闲列表(<font color=\"#008000\">并发执行</font>)</p>\n</li>\n</ol>\n<h3>evacuation</h3><br><font color=\"#DC143C\">暂停阶段</font><br>选定需要回收的region加入到CSet中，并行地把CSet中每个region的活对象拷贝到新的region里。<br><br><h3>G1 GC选取CSet的模式</h3>\n\n<ol>\n<li>Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。 </li>\n<li>Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。</li>\n<li>Full GC：确切地说Full GC算是一种异常情况下的GC，当Mixed GC无法跟上应用程序分配内存的速度时，Java 9及之前会切换到serial old GC/Java 10开始多线程并行，来收集整个GC heap(该GC heap包括Java 7及之前的perm)。<br><strong>触发Full GC的情况</strong>：global concurrent marking时old gen被填满；对象晋升失败；巨型对象分配失败</li>\n</ol>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><h3>G1 GC的优点</h3>\n\n<ol>\n<li>可预测停顿，维护CSet来尽量使停顿时间小于用户设置的MaxGCPauseMillis。</li>\n<li>基于SATB效率高，remark阶段使用SATB write barrier比CMS的INC write barrier效率高，易于控制停顿</li>\n<li>并行与并发结合</li>\n<li>整合空间，引入region来划分堆，没有了复制算法浪费内存和标记清除法存在大量内存碎片的问题</li>\n</ol>\n<h3>G1 GC适合在什么场景下使用?</h3>\n\n<ol>\n<li>堆内存较大</li>\n<li>Full-GC执行太频繁，或者持续的时间太长</li>\n<li>GC暂停时间太长</li>\n<li>对象分配的速度差距较大</li>\n</ol>\n<h3>G1 GC常用参数解释</h3>\n\n<blockquote>\n<p>具体参数及解释查看<a href=\"https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">垃圾优先型垃圾回收器调优</font></a></p>\n<p>-XX:MaxGCPauseMillis=200 设置GC的最大暂停时间为200ms。</p>\n<p>-XX:G1HeapRegionSize=n 设置的region区域的大小。值是2的n次幂，范围是1MB到32MB之间。</p>\n<p>-XX:ParallelGCThreads=n 设置STW工作线程数的值。</p>\n<p>-XX:ConcGCThreads=n 设置并行标记的线程数。</p>\n<p>-XX:InitiatingHeapOccupancyPercent=45 设置触发标记周期的Java堆占用率阈值。默认占用率是整个Java堆的45%。</p>\n<p>-XX:G1ReservePercent=10 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%</p>\n</blockquote>\n<h3>G1 GC调优</h3>\n\n<p>参考<a href=\"https://zhaoyanblog.com/archives/440.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">G1垃圾收集器(六) 之 命令行选项和最佳实践</font></a></p>\n<ol>\n<li>不设置young gen大小。通过参数显式设置young gen大小可能会使设定的pause time失效。G1是通过控制young gen的region个数来控制young GC的开销。</li>\n<li>MaxGCPauseMillis停顿时间应考虑设置90%以上时间都能达到目标的值。因为MaxGCPauseMillis是最大停顿时间，可以保证大部分停顿时间在设定范围内。</li>\n<li><p>有关溢出和用尽的日志消息的问题解决。(没有足够的内存，供存活者和/或晋升对象使用。Java堆不能扩展，因为已达到最大值。)</p>\n<ul>\n<li><p>增加 -XX:G1ReservePercent=n 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量，默认是10。</p>\n</li>\n<li><p>减少 -XX:InitiatingHeapOccupancyPercent=45 提前启动标记周期，默认占用率是整个Java堆的 45%。</p>\n</li>\n<li><p>增加 -XX:ConcGCThreads=n 选项的值来增加并行标记线程的数目。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li><a href=\"https://hllvm-group.iteye.com/group/topic/44381#post-272188\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 请教G1算法的原理</font></a></li>\n<li><a href=\"https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 关于incremental update与SATB的一点理解</font></a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1378263\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">可能是最全面的G1学习笔记 - 阿杜的世界</font></a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">Getting Started with the G1 Garbage Collector - Oracle</font></a></li>\n<li><a href=\"https://tech.meituan.com/g1.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">Java Hotspot G1 GC的一些关键技术 - 美团技术团队</font></a></li>\n<li><a href=\"https://www.jianshu.com/p/d302ed6e2405\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">深入理解Java G1垃圾收集器</font></a></li>\n<li><a href=\"https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">垃圾优先型垃圾回收器调优</font></a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>G1(Garbage-First )垃圾回收算法，HotspotVM的四种GC算法之一。<br>G1垃圾回收器启动参数-XX:+UseG1GC，Java 9开始被作为默认垃圾回收器。<br>这里基于读者已经了解其他三种GC算法，我作为一个blog搬运工(关于G1算法的优秀blog请看参考资料)，谈一下对G1算法的总结和理解思路。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h4>GC算法中的并行和并发</h4>\n\n<p>并发(concurrent):通常指GC线程与应用程序线程宏观上看是一起执行的</p>\n<p>并行(parallel):指多个线程进行垃圾回收，此时应用程序线程是暂停的</p>\n<h4>三色标记</h4>\n\n<p>黑色:该对象与它的子对象都被扫描</p>\n<p>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</p>\n<p>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</p>\n<h4>RSet(remembered set)</h4>\n\n<p>该集合用来记录并跟踪其它region指向该region中对象的引用，使统计region中存活对象的效率更高</p>\n<h4>CSet(collection set)</h4>\n\n<p>记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old-&gt;young和old-&gt;old的跨代对象引用，只要扫描对应的CSet中的RSet即可。</p>\n<h4>SATB</h4>\n\n<p>SATB全称snapshot-at-the-beginning，SATB保证了在并发标记过程中新分配对象不会漏标</p>\n<p>（1）<strong>SATB工作的具体过程</strong></p>\n<p><img src=\"/images/satb.png\" width=\"50%\" height=\"50%\"></p>\n<ol>\n<li>[top, end]区域为空闲区，top向右移来给对象在[next TAMS, top]之间分配内存</li>\n<li>并发标记在[previous TAMS, next TAMS]区间进行，并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照Bitmap，所有垃圾对象能通过快照被识别出来</li>\n<li>下一轮开始时，将top所在的地址赋值给next TAMS</li>\n</ol>\n<p>（2）<strong>SATB write barrier如何解决白色对象被漏标</strong></p>\n<p>(引用自<a href=\"https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 关于incremental update与SATB的一点理解</font></a>)</p>\n<blockquote>\n<p>一个white对象在并发标记阶段会被漏标的充分必要条件是： </p>\n<p>1、mutator插入了一个从black对象到该white对象的新引用 </p>\n<p>2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。 </p>\n<p>因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 </p>\n<p>Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。</p>\n<p>SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。</p>\n</blockquote>\n<p>（3）<strong>Write barrier功能</strong></p>\n<ol>\n<li>跨region的引用同步到RSet里</li>\n<li>同步SATB快照的完整性</li>\n</ol>\n<h2 id=\"分代G1算法\"><a href=\"#分代G1算法\" class=\"headerlink\" title=\"分代G1算法\"></a>分代G1算法</h2><p>G1算法引入了region，分区young gen和old gen没有明确的界限，当新建对象大小超过region大小一半时，直接在新的一个或多个连续region中分配，并标记为Humongous,为巨型对象。</p>\n<p><img src=\"/images/G1Gen.png\" width=\"50%\" height=\"50%\"></p>\n<p>把GC过程分成 <strong>global concurrent marking</strong> 和 <strong>evacuation</strong> 两个阶段且相互独立执行的理解更友好。其他的思路我也看过，将GC分为四个阶段，最后一个阶段是筛选回收，这种理解方法并不好，因为真正回收内存的操作并不一定是紧接着在完成所有标记之后。</p>\n<h3>global concurrent marking 基于SATB</h3>\n\n<ol>\n<li><p><strong>初始标记（initial marking）</strong><font color=\"#DC143C\">暂停阶段</font><br>从GC Roots开始标记直接可达的对象。在G1垃圾回收器中还会存在young GC，这个阶段借用了young GC的暂停</p>\n</li>\n<li><p><strong>并发标记（concurrent marking）</strong><font color=\"#008000\">并发阶段</font><br>从GC Roots开始对堆中的对象标记，标记线程与应用程序线程并行执行，这个过程基于SATB。还会伴随着扫描SATB write barrier记录的引用变化</p>\n</li>\n<li><p><strong>最终标记（final marking / remarking）</strong><font color=\"#DC143C\">暂停阶段</font><br>处理还未扫描完的SATB write barrier。CMS的remark阶段扫描的是INC write barrier，由于这个无法发现Concurrent Mark期间堆外根集（寄存器、栈）的引用变化，所以CMS的remark阶段可能会很慢。</p>\n</li>\n<li><p><strong>筛选回收（cleanup）</strong><br>在SATB的Bitmap中统计各个region中存活对象，擦除RSet(<font color=\"#DC143C\">Stop the World</font>)。重置空白区域并将其返回到空闲列表(<font color=\"#008000\">并发执行</font>)</p>\n</li>\n</ol>\n<h3>evacuation</h3><br><font color=\"#DC143C\">暂停阶段</font><br>选定需要回收的region加入到CSet中，并行地把CSet中每个region的活对象拷贝到新的region里。<br><br><h3>G1 GC选取CSet的模式</h3>\n\n<ol>\n<li>Young GC：选定所有young gen里的region。通过控制young gen的region个数来控制young GC的开销。 </li>\n<li>Mixed GC：选定所有young gen里的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region。在用户指定的开销目标范围内尽可能选择收益高的old gen region。</li>\n<li>Full GC：确切地说Full GC算是一种异常情况下的GC，当Mixed GC无法跟上应用程序分配内存的速度时，Java 9及之前会切换到serial old GC/Java 10开始多线程并行，来收集整个GC heap(该GC heap包括Java 7及之前的perm)。<br><strong>触发Full GC的情况</strong>：global concurrent marking时old gen被填满；对象晋升失败；巨型对象分配失败</li>\n</ol>\n<h2 id=\"G1垃圾回收器\"><a href=\"#G1垃圾回收器\" class=\"headerlink\" title=\"G1垃圾回收器\"></a>G1垃圾回收器</h2><h3>G1 GC的优点</h3>\n\n<ol>\n<li>可预测停顿，维护CSet来尽量使停顿时间小于用户设置的MaxGCPauseMillis。</li>\n<li>基于SATB效率高，remark阶段使用SATB write barrier比CMS的INC write barrier效率高，易于控制停顿</li>\n<li>并行与并发结合</li>\n<li>整合空间，引入region来划分堆，没有了复制算法浪费内存和标记清除法存在大量内存碎片的问题</li>\n</ol>\n<h3>G1 GC适合在什么场景下使用?</h3>\n\n<ol>\n<li>堆内存较大</li>\n<li>Full-GC执行太频繁，或者持续的时间太长</li>\n<li>GC暂停时间太长</li>\n<li>对象分配的速度差距较大</li>\n</ol>\n<h3>G1 GC常用参数解释</h3>\n\n<blockquote>\n<p>具体参数及解释查看<a href=\"https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">垃圾优先型垃圾回收器调优</font></a></p>\n<p>-XX:MaxGCPauseMillis=200 设置GC的最大暂停时间为200ms。</p>\n<p>-XX:G1HeapRegionSize=n 设置的region区域的大小。值是2的n次幂，范围是1MB到32MB之间。</p>\n<p>-XX:ParallelGCThreads=n 设置STW工作线程数的值。</p>\n<p>-XX:ConcGCThreads=n 设置并行标记的线程数。</p>\n<p>-XX:InitiatingHeapOccupancyPercent=45 设置触发标记周期的Java堆占用率阈值。默认占用率是整个Java堆的45%。</p>\n<p>-XX:G1ReservePercent=10 设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险。默认值是 10%</p>\n</blockquote>\n<h3>G1 GC调优</h3>\n\n<p>参考<a href=\"https://zhaoyanblog.com/archives/440.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">G1垃圾收集器(六) 之 命令行选项和最佳实践</font></a></p>\n<ol>\n<li>不设置young gen大小。通过参数显式设置young gen大小可能会使设定的pause time失效。G1是通过控制young gen的region个数来控制young GC的开销。</li>\n<li>MaxGCPauseMillis停顿时间应考虑设置90%以上时间都能达到目标的值。因为MaxGCPauseMillis是最大停顿时间，可以保证大部分停顿时间在设定范围内。</li>\n<li><p>有关溢出和用尽的日志消息的问题解决。(没有足够的内存，供存活者和/或晋升对象使用。Java堆不能扩展，因为已达到最大值。)</p>\n<ul>\n<li><p>增加 -XX:G1ReservePercent=n 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量，默认是10。</p>\n</li>\n<li><p>减少 -XX:InitiatingHeapOccupancyPercent=45 提前启动标记周期，默认占用率是整个Java堆的 45%。</p>\n</li>\n<li><p>增加 -XX:ConcGCThreads=n 选项的值来增加并行标记线程的数目。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h2><ul>\n<li><a href=\"https://hllvm-group.iteye.com/group/topic/44381#post-272188\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 请教G1算法的原理</font></a></li>\n<li><a href=\"https://link.zhihu.com/?target=http%3A//hllvm.group.iteye.com/group/topic/44529\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">[HotSpot VM] 关于incremental update与SATB的一点理解</font></a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1378263\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">可能是最全面的G1学习笔记 - 阿杜的世界</font></a></li>\n<li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">Getting Started with the G1 Garbage Collector - Oracle</font></a></li>\n<li><a href=\"https://tech.meituan.com/g1.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">Java Hotspot G1 GC的一些关键技术 - 美团技术团队</font></a></li>\n<li><a href=\"https://www.jianshu.com/p/d302ed6e2405\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">深入理解Java G1垃圾收集器</font></a></li>\n<li><a href=\"https://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html\" target=\"_blank\" rel=\"noopener\"><font color=\"#0000CD\">垃圾优先型垃圾回收器调优</font></a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjtrzgdmn0000dcxv2w124uhw","category_id":"cjtrzgdmt0004dcxvj84k1raw","_id":"cjtrzgdmz000bdcxvm1yiv9ev"},{"post_id":"cjtrzgdmw0007dcxvn1dwfjte","category_id":"cjtrzgdmt0004dcxvj84k1raw","_id":"cjtrzgdn0000cdcxva88lkqh9"},{"post_id":"cjtrzgdmr0002dcxvz4k6hsg0","category_id":"cjtrzgdmt0004dcxvj84k1raw","_id":"cjtrzgdn0000ddcxvpdhd9bm5"},{"post_id":"cjtrzgdmu0005dcxvnsi7e7ib","category_id":"cjtrzgdmz000adcxvya62cnum","_id":"cjtrzgdn1000gdcxvikce4qg3"},{"post_id":"cjtrzgdmv0006dcxvklzvk54b","category_id":"cjtrzgdmz000adcxvya62cnum","_id":"cjtrzgdn1000hdcxv02amik6r"},{"post_id":"cjtrzgdmy0009dcxvpvpj7a55","category_id":"cjtrzgdn0000fdcxvs8rsezdw","_id":"cjtrzgdn1000idcxvbb7arya0"},{"post_id":"cjtrzgdqf000ldcxvr7lsjhpj","category_id":"cjtrzgdn0000fdcxvs8rsezdw","_id":"cjtrzgdqi000ndcxvo5ye9n7i"},{"post_id":"cjtrzgdqc000jdcxvfwq8seu3","category_id":"cjtrzgdqh000mdcxvgcrlykoq","_id":"cjtrzgdqi000odcxvzb13f6gw"}],"PostTag":[],"Tag":[]}}